// todo make all non byte strings byte strings

// todo: formatter should be able to format macros, a macro can define what formatting to use
skel! {

    delimiters: b'{' | b'}' | b'(' | b')' | b';' | b'!' | b'=' | b'|'|b':'|b','|b'<'|b'>' | b'?'|b'.',
    // two char delimeters

    newline: b'\n',

    other_whitespace: b'\t' | b0xC | b'\r' | b' ',

    whitespace: other_whitespace!() | newline!(),
    // can use raw num bytes
    any: 0..=255,



    group keyword {
        statement TYPE: "type";
        statement FUNCTION: "fn";
        statement LET: "let";
        statement MUT: "mut";
        statement CONST: "const";
        statement STATIC: "static";
        statement EXTERN: "extern";
        statement MOD: "mod";
        statement USE: "use";
        statement AS: "as";
        statement TRAIT: "trait";
        statement IMPL: "impl";
        statement ENUM: "enum";
        statement STRUCT: "struct";
        statement UNION: "union";


    }








    // todo: goto keyword

    pattern Delimit(start: Literal, middle: Pattern, end?: Literal = self::start)-> Pattern {
        self::start self::middle self::end
    }

    pattern SquareBrackets(middle:Pattern) -> Delimit(b'[',middle,b']');
    pattern Parentheses(middle:Pattern) -> Delimit(b'(',middle,b')');
    pattern CurlyBrackets(middle:Pattern) -> Delimit(b'{',middle,b'}');
    pattern AngleBrackets(middle:Pattern) -> Delimit(b'<',middle,b'>');


    pattern SeparatedList(pattern:Pattern, separator:Pattern, optional_trailing:bool) -> Pattern {
        (self::pattern self::separator)* if optional_trailing {self::pattern?}
    }

    pattern CommaSeparated(pattern:Pattern,optional_trailing:bool) -> Separated(self::pattern, b',', self::optional_trailing);
    pattern SemicolonSeparated(pattern:Pattern,optional_trailing:bool) -> Separated(self::pattern, b';', self::optional_trailing);

    pattern RoundList(middle:Pattern) -> Parentheses(SeparatedList(self::middle, b',', true));
    pattern SquareList(middle:Pattern) -> SquareBrackets(SeparatedList(self::middle, b',', true));
    pattern CurlyList(middle:Pattern) -> CurlyBrackets(SeparatedList(self::middle, b',', true));
    pattern AngleList(middle:Pattern) -> AngleBrackets(SeparatedList(self::middle, b',', true));

    pattern Tuple(elements:Type) as Type -> RoundList(elements);
    pattern Tuple(elements:Expression) as Expression-> RoundList(elements);

    // TODO: need a way to type an array

    pattern Array(elements:Expression) as Expression -> SquareList(elements);


    pattern FunctionCallArguments(name:Pattern, args:Pattern) -> RoundList(args);

    pattern Identifier {

        first: Alpha | Underscore,
        rest: self::first | Numeric,

        Identifier() -> {
            self::first self::rest*
        }
    }

    pattern TypeGeneric {
        name: Identifier,
        generics: AngleList(Type),

        TypeGeneric() {
            self::name self::generics?
        }
    }

    pattern Type {
        name: Identifier,
        generics: TypeGeneric,

        Type() -> {
            self::name self::generics?
        }
    }


    pattern TypedAssignmentTernary {


        type_specifier?: if self::has_type { ':' self::type } 
        assignment?:  if self::HAS_ASSIGNMENT {'=' self::value},
        type_part?: if self::TYPE_OPTIONAL self::type_specifier? else self::type_specifier


        (name:Identifier, type:Pattern, value:Pattern, TYPE_OPTIONAL:bool; HAS_TYPE:bool, HAS_ASSIGNMENT:bool ) -> {
            self::name self::type_part self::assignment
        }
    }


    pattern VariableDefinition(name:Identifier, type:Type, value:Expression)-> TypedAssignmentTernary(self::name, self::type, self::value, false, true);

     

    pattern GenericDefinition {

        name: Identifier,

        generic_item: TypedAssignmentTernary(Identifier, Type, Type),

        generics: AngleList(self::generic_item),

        GenericDefinition() {
            self::name self::generics
        }
    }



    pattern TypeAlias {
        keyword = Keyword(keyword::TYPE)
        name: Identifier,
        bounds: TypeGeneric,
        generics: GenericDefinition,
        setting:TypedAssignmentTernary(self::name self::generics, self::bounds, Type),

        TypeAlias() -> {
            self::keyword self::setting


        }
    }

    /*
    #[meta(...)]
        
        #[meta(...)]
     
        #[protocol(
        error = "TestError",
        fields((
            // if version is not specified it will default to the latest version
            java(encoding = "be"),
            bedrock(encoding = "le")
        ),
        (
            java(encoding = "var"),
            bedrock(encoding = "zigzag")
        ),
        (
            java(version = "2..34",len = "u8", inner(len = "u32_var") ),
            bedrock(version = "3..22",len = "u8",inner(len = "u32_be"))
        )
        )
    )]
     
     */

    
    pattern Meta {
        name: Identifier,
        values:SquareListList(TypedAssignmentTernary(Identifier, Type, Expression)),

        Meta() -> {
            self::keyword self::name self::values
        }
    }
    


    pattern KeywordHeader {
        keyword = self::
        name: Identifier,
        generics: AngleList(Type),


        KeywordHeader(keyword:string) -> {
            self::keyword self::name self::generics
        }
    }



    pattern Struct {
        keyword = Keyword(keyword::STRUCT),
        name: Identifier,
        generics: AngleList(Type),
        fields: CurlyList(VariableDefinition),

        Struct() -> {
            self::keyword self::name self::generics self::fields
        }
    }



    pattern Function {
        keyword: Keyword(keyword::FUNCTION),
        name: Identifier,
        parameters: RoundList(VariableDefinition, b',', true),
        return_type: Type,
        return_operator: ,
        body: ,

        Function() -> {
            self::keyword self::name self::parameters self::return_type self::body
        }
    }


    //pattern Indexing(index:Pattern) -> SquareBrackets(index);




    // enum QuotePrefix {
    //     Raw: "r",
    //     Binary: "b",
    //     Unicode: "u",
    //     Formatted: "f",
    // }




    // pattern Quotes(prefix:QuotePrefix, inner:Pattern) ->{Delimit(b'"',middle)};




    // struct DoubleQuotes<MIDDLE>: Delimit<b'"',MIDDLE,b'"'> {
    //     middle: MIDDLE
    // },








    /// A patten that contains all the different types of patterns
    quantifier All;
    quantifier AtLeastOne;
    quantifier ZeroOrOne;

    /// Some Sort of Pattern
    statement Pattern

    /// States that the pattern is optional at the end
    statement OptionalAtEnd<>

    statement RequiredAtEnd

    abstract Separator<PAT,LIT> {
        pattern: Pattern = PAT,
        separator: Literal = LIT,
        layout() -> {
            self::pattern self::separator
        }
    },



    /// Required Whitespace
    pat HorizontalWhitespace:Literal = b' '|b'\t'|b'\r'|b0xC;
    struct VerticalWhitespace:Literal = b'\n';

    pat Whitespace:Literal = HorizontalWhitespace | VerticalWhitespace;



    /// A structure that

    abstract SeparatedGroup<PAT,SEPARATOR,START,END,END_REQUIRED>: Delimit<START,Separator<PAT,SEPARATOR>,END>{

    }



    statement Expression:Pattern;

    struct Brace<REQUIRED_KEYWORD[]>: SeparatedGroup<Expression, ";", "{", "}", true> {

        required_keyword: REQUIRED_KEYWORD


    };

    alias CommaList<Pat,Start>: SeparatedGroup<Pat, OptionalAtEnd<",">>;

    /// A pattern that is a literal
    statement Literal: Pattern;



    interface List:SeparatedGroup {

    },


    scope:SeparatedGroup {
        start: '{',
        end: '}',
        separator: ';',
        // like a fn scope can contain return, break, continue, and other scopes
        can_contain(pattern:Pattern) -> {
            pattern
        }
    },
    /// Notates that something is a type declaration
    statement Type:Pattern;




    structure: {

    }



    scope : {
        start: '{',
        end: '}',
        separator: ';',
        // like a fn scope can contain return, break, continue, and other scopes
        can_contain(pattern:Pattern) -> {
            pattern
        }
    }


    pattern Keyword {
        ident: Identifier,

        Keyword() -> {
            self::ident ansi::Whitespace
        }
    }

    abstract Pattern: {
        // Operator-specific documentation must be defined in subclasses
        fn doc(&self) -> String;
    }


    inbuilt {
        abstract Pattern;

        abstract Literal extends Pattern;
        abstract String extends Literal;
        abstract Number extends Literal;
        abstract Char extends Literal;
        abstract Boolean extends Literal;
    }

    group math {
        use super::ansi::punctuation::{Plus, Minus, Asterisk, Slash, Percent, CircumflexAccent,
            CommercialAt, Ampersand,Not, VerticalLine, Tilde, Dollar, Hash, GraveAccent,
            LowLine, Bang, Colon, Semicolon, LessThan, GreaterThan, Equals};

        alias Add: Plus;
        alias Subtract: Minus;
        alias Multiply: Asterisk;
        alias Divide: Slash;
        alias Modulo: Percent;
        alias Power: CircumflexAccent;
        alias Factorial: Bang;
        alias BitwiseAnd: Ampersand;
        alias BitwiseOr: VerticalLine;
        alias BitwiseXor: Tilde;
        pattern BitwiseNot: Not | Bang;
        alias MatrixMultiply: CommercialAt;

        alias GreaterThan: GreaterThan;
        alias LessThan: LessThan;

        pattern GreaterThanOrEqualTo: GreaterThan+Equals;
        pattern LessThanOrEqualTo: LessThan + Equals;
        pattern EqualTo: Equals+Equals;

        /// The not equal to operator
        pattern NotEqualTo: Bang + Equals;

        /// The strict equal to operator
        pattern StrictEqualTo: Equals + Equals + Equals;

        /// The strict not equal to operator
        pattern StrictNotEqualTo: Bang + Equals + Equals;

        /// The assignment operator
        alias Assign: Equals;

        pattern AddAssign: Plus + Equals;
    }

    group brackets {
        group round {
            use super::punctuation::{LeftParenthesis, RightParenthesis};
            alias Open: LeftParenthesis;
            alias Close: RightParenthesis;
        }
        group square {
            use super::punctuation::{LeftBracket, RightBracket};
            alias Open: LeftBracket;
            alias Close: RightBracket;
        }

        group curly {
            use super::punctuation::{LeftCurlyBracket, RightCurlyBracket};
            alias Open: LeftCurlyBracket;
            alias Close: RightCurlyBracket;
        }

        group angle {
            use super::punctuation::{LessThan, GreaterThan};
            char Open: LessThan;
            char Close: GreaterThan;
        }
    }


    group ansi {


        enum Control {
            Null: 0x0;
            Enquiry: 0x5;
            Acknowledge: 0x6;
            Bell: 0x7;
            Backspace: 0x8;
            LineFeed: '\n';
            VerticalTab: 0xB;
            FormFeed: 0xC;
            CarriageReturn: '\r';
            ShiftOut: 0xE;
            ShiftIn: 0xF;
            DataLinkEscape: 0x10;
            DeviceControlOne: 0x11;
            DeviceControlTwo: 0x12;
            DeviceControlThree: 0x13;
            DeviceControlFour: 0x14;
            NegativeAcknowledge: 0x15;
            SynchronousIdle: 0x16;
            EndOfTransmissionBlock: 0x17;
            Cancel: 0x18;
            EndOfMedium: 0x19;
            Substitute: 0x1A;
            Escape: 0x1B;
            FileSeparator: 0x1C;
            GroupSeparator: 0x1D;
            RecordSeparator: 0x1E;
            UnitSeparator: 0x1F;
            Delete: 0x7F;
        }

        use Control::{Tab, LineFeed, CarriageReturn, FormFeed, VerticalTab, Space};

        enum Whitespace {
            Newline: LineFeed;
            Return: CarriageReturn;
            HorizontalTab: Tab;
            VerticalTab: VerticalTab;
            FormFeed: FormFeed;
            Space: ' ';
        }

        enum Punctuation {
            CommercialAt: '@';
            Backslash: '\\';
            CircumflexAccent: '^';
            Underscore: '_';
            GraveAccent: '`';
            VerticalLine: '|';
            Tilde: '~';
            Bang: '!';
            DoubleQuote: '"';
            Hash: '#';
            Dollar: '$';
            Percent: '%';
            Ampersand: '&';
            SingleQuote: '\'';
            LeftParenthesis: '(';
            RightParenthesis: ')';
            Asterisk: '*';
            Plus: '+';
            Comma: ',';
            Minus: '-';
            Period: '.';
            Slash: '/';
            Colon: ':';
            Semicolon: ';';
            LessThan: '<';
            Equals: '=';
            GreaterThan: '>';
            Question: '?';
            LeftBracket: '[';
            RightBracket: ']';
            LeftCurlyBracket: '{';
            RightCurlyBracket: '}';
            Not:'¬';
        }



        enum LatinCapital {
            A: 'A';
            B: 'B';
            C: 'C';
            D: 'D';
            E: 'E';
            F: 'F';
            G: 'G';
            H: 'H';
            I: 'I';
            J: 'J';
            K: 'K';
            L: 'L';
            M: 'M';
            N: 'N';
            O: 'O';
            P: 'P';
            Q: 'Q';
            R: 'R';
            S: 'S';
            T: 'T';
            U: 'U';
            V: 'V';
            W: 'W';
            X: 'X';
            Y: 'Y';
            Z: 'Z';
        }

        enum LatinSmall {
            A: 'a';
            B: 'b';
            C: 'c';
            D: 'd';
            E: 'e';
            F: 'f';
            G: 'g';
            H: 'h';
            I: 'i';
            J: 'j';
            K: 'k';
            L: 'l';
            M: 'm';
            N: 'n';
            O: 'o';
            P: 'p';
            Q: 'q';
            R: 'r';
            S: 's';
            T: 't';
            U: 'u';
            V: 'v';
            W: 'w';
            X: 'x';
            Y: 'y';
            Z: 'z';
        }

        enum Digits {
            Zero: '0';
            One: '1';
            Two: '2';
            Three: '3';
            Four: '4';
            Five: '5';
            Six: '6';
            Seven: '7';
            Eight: '8';
            Nine: '9';
        }

        pattern Alpha: LatinCapital | LatinSmall;
        pattern Alphanumeric: Alpha | Numeric;
        alias Numeric: Digits;

        pattern HorizontalWhitespace: Whitespace::Space | Whitespace::Tab | Whitespace::CarriageReturn | Whitespace::FormFeed | Whitespace::VerticalTab;
        pattern VerticalWhitespace: Whitespace::Newline;

        // these have to be very explicit
    }

    use ansi::{Alpha,Whitespace,Numeric,Punctuation::{self,Underscore,Period,DoubleQuote}};
















    pattern Type: Pattern {
        name: Identifier,
        generics: Delimit<CommaList<Type>>,

        Type() -> {
            self::name self::generics?
        }
    }







    marker Primitive: Pattern;

    pattern String: Delimit<DoubleQuote, All> + Primitive {
        fn skip() -> {
            self::backslash super::start
        }
    }

    pattern Char: Delimit<SingleQuote, All> + Primitive {
        fn skip() -> {
            self::backslash super::start
        }
    }

    group number {

        use super::ansi::{Numeric,Period,Alphanumeric};


        enum Prefix {
            Binary: "0b",
            Octal: "0o",
            Hexadecimal: "0x",
        }

        enum Endian {
            Little: "le",
            Big: "be",
            Native: "ne",
        }

        enum IntegerSuffix {
            u8: "u8",
            u16: "u16",
            u32: "u32",
            u64: "u64",
            u128: "u128",
            i8: "i8",
            i16: "i16",
            i32: "i32",
            i64: "i64",
            i128: "i128",
        }

        enum FloatSuffix {
            f32: "f32",
            f64: "f64"
        }


        /// The exponent part of a number
        pattern Exponent {
            e: ansi::LatinCapital::E | ansi::LatinSmall::E
            sign: math::Add | math::Subtract,
            multiplier: Numeric+,

            Exponent() -> {
                self::e self::sign? self::multiplier
            }
        }

        pattern Binary:Literal {
            prefix: Prefix::Binary,
            number: Numeric,

            Binary() -> {
                self::prefix self::number
            }
        }

        const MAX_INT_SIZE = 128;


        enum NumberFormat {
            Decimal: Numeric+,
            Binary: "0b" + ('1' | '0'){1,MAX_INT_SIZE},
            Octal: "o" + ('0'..'7'){1,MAX_INT_SIZE/8},
            Hexadecimal: "x",
        }


        pattern Float:Literal {
            negative: math::Subtract,
            number: ,
            fractional:  Numeric+,
            exponent: Exponent,
            dot:Period,
            suffix: FloatSuffix,

            Float() -> {
                self::negative? self::integer?  (self::dot self::fractional)? self::exponent? self::suffix?
            }
        }

        enum NumberDelimiter {
            Comma: ',',
            Underscore: '_',
        }


        pattern Number:Literal {
            integer: Numeric+,
            fractional: Period Numeric+,
            exponent: Exponent,

            Number() -> {
                self::integer self::fractional? self::exponent?
            }
        }

        pattern Integer:Literal {
            decimal:Prefix
            layout() -> {
                self::decimal | self::binary | self::octal | self::hexadecimal
            }
        }







    }



    /// A boolean value
    pattern Boolean: Literal {
        true: "true",
        false: "false",
        layout() -> {
            self::true | self::false
        }
    }

    abstract VariableDefinition



    group function {
        abstract Function extends Pattern {
            // like inline or static
            meta: Pattern[],
            name: Identifier?,
            parameters: Delimit<CommaList<VariableDefinition>>,
            return_type: Type,
            body: Brace<Pattern>,
        }




    }


    group operator {

        meta Expression is builtin::Pattern;

         // Abstract base class for operators to avoid redundancy
        abstract Operator is Pattern {
            symbol: Pattern;
            identifier: Pattern;
            type: OperatorType;
            precedence: number;
            associativity: Associativity;

            // converts the op to a function call.
            fn to_function() -> {
                self::identifier function::call
            }
        }

        abstract PrefixOperator{

            rhs: Expression,
            operator: Operator,

            Prefix(identifier:Pattern, symbol:Pattern,  precedence:Number) -> {
                self::operator {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::RightToLeft,
                };
            }





        }




        // what do i call this type of operator |x| where it is surrounded by two things





        abstract PrefixExpression is OperatorExpression {
            PrefixExpression() {
                operator: Prefix,
                lhs: Expression,
            }
        }

        abstract Infix is OperatorExpression {
            Infix() {
                operator: Operator,
                lhs: Expression,
                rhs: Expression,
            }
        }


        abstract Prefix is Operator {
            Prefix( identifier:Pattern, symbol:Pattern,  precedence:Number) -> {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::RightToLeft,
                };

                self
            }
        }




        abstract Infix is Operator {

            rhs: Expression,
            lhs: Expression,


            Infix() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Binary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };
                self::lhs super self::rhs
            }
        }

        abstract Postfix is Operator {

            Postfix() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };

                self::lhs super
            }
        }





        abstract Ternary<RHO,LHO> is Operator {
            rhs: RHO,
            lhs:


            Ternary() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Ternary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };

                self::lhs super self::middle super self::rhs
            }
        }




        /// The type of operator
        enum OperatorType {
            // Binary operators take two operands
            Binary,
            // Unary operators take one operand
            Unary,
            // Ternary operators take three operands
            Ternary,
        }

        enum Associativity {
            /// Evaluates from left to right
            LeftToRight,
            /// Evaluates from right to left
            RightToLeft,
        }

        /// Assigns the value of the right operand to the left operand.
        struct Assignment is Operator {
            symbol: super::math::Assign,
            type: OperatorType::Binary,
            precedence: 1,
            associativity: Associativity::RightToLeft,
        }

        struct EqualTo is Operator {
            symbol: "==",
            type: OperatorType::Binary,
            precedence: 2,
            associativity: Associativity::LeftToRight,
            doc: "Checks if the left operand is equal to the right operand",
        }



    }



    variable: {

        prefix: {
            mutable:{
                def: "~" |"mutable",
                layout() -> {
                    self
                }
            },
            macro_invocation: {},
            static: "static",
            const: "const",

        },


        defined_as: ":",

        layout() -> {
            self::prefix super::identifier self::defined_as super::type
        }
    },



    function : {
        keyword: "fn",

        param : {
            start: '(',
            end: ')',
            suffix: {
                error: '?',
                layout() {// declares the order
                    error
                }
            }

            middle*: {
                separator:','

                layout() -> {
                    ::variable self::separator*?  // optional end is *?
                }
            }

            layout() -> {
                self::start self::middle*? self::end self::suffix
            }



        },


        layout() -> {
            self::keyword self::param self::return error
        }

    },

    variable_definition : {
        // let ...
    }

    fn fizz_bizz (ffo:u8,f:u8)

    variable_type: {
        start: b":",
        end: b";",
        separator: b",",
    },

    method : {
        instance_call: b'.',
        static_call: b"::",
    },




    macro: {
        call: b'!',
    }




    fn_call_suffixes: macro_call!(),

    string_quotes: b'"',
    char_quotes: b'\'',

    quotes: string_quotes!() | char_quotes!(),

    backslash: b'\\',

    // raw | binary | unicode | formatted
    quote_prefixes: b'r' | b'b'| b'u'| b'f',
    // TODO: integrate this here ^
    prefixed_quotes: b"r\"" | b"b\""| b"u\""| b"f\"",

    // escape sequences
    // should we include regexp escape sequences in helix?
    // newline | carriage return | tab | null | hex | unicode | unicode extended | single quote
    escape_sequences: b"\\n" | b"\\r" | b"\\t" | b"\\0" | b"\\x" | b"\\u" | b"\\U" | b"\\'",


    two_len_ops: b"==" | b"!=" | b"<=" | b">=" | b"//" | b"**" |
    b"<<" | b">>" | b"r+" | b"r-"| b"r*" | b"r/" | b"r%" | b"r&" | b"r|" |
    b"r^" | b"+=" | b"-=" | b"*=" | b"/=" | b"%=" | b"&=" | b"|=" | b"^=" |
    b"=>" | b"@=" | b"->" | b"<-" | b"<=" | b">=" | b"&&" | b"--" |
    b"::" | b"||" | b"++" | b"__" | b"?=",



    three_len_ops: b"===" | b"!==" | b"..." | b"r//" | b"r**" | b"r<<" | b"r>>" | b"//=" | b"**=" | b"<<=" |
    b">>=" | b"??" | b"|:",

    // hex: numeric!() | b'a'..=b'f' | b'A'..=b'F',


    // method_call: b'.',
    // static_method_call: b"::",
    // method_error: b'?',


    // fn_definition_error_suffix: b'?',
    // fn_definition_suffixes: fn_definition_error_suffix!(),


    // fn_definition: b"fn",

    // // used for match statements
    // implies: b"=>",

    // fn_error: b'?',
    // // idk abt this copiolet gave this : fn_error_eq: b"?=",

    // fn_return: b"->",

    // fn_param_start: b'(',
    // fn_param_end: b')',

    // scope_start: b'{',
    // scope_end: b'}',

    // array_start: b'[',
    // array_end: b']',

    // tuple_start: b'(',
    // tuple_end: b')',

    // // make thing that does this

    // // numeric_prefix : {
    // //     // all of these patterns are in numeric prefix and also their own patterns that  can be used...
    // //     ordinal: b'o',
    // // }


    // // idk about big O
    // ordinal_numeric:b'o' ,

    // // little b is
    // binary_numeric: b'b',

    // // u is unicode. u4u32 would make it into the respective type from that char to the number
    // unicode_numeric: b'u',
    // numeric_hex: b'x' | b"0x",

    // big_endian: b'b',
    // little_endian: b'l',
    // native_endian: b'n',

    // numeric_endian_infixes: big_endian!() | little_endian!() | native_endian!(),
    // numeric_prefixes: ordinal!() |  binary_numeric!(),

    underscore: b'_',
    uppercase: b'A'..=b'Z',
    lowercase: b'a'..=b'z',
    numeric: b'0'..=b'9',

    alphanumeric: lowercase!() | uppercase!() | numeric!(),



    identifier: {
        prefix:{
            raw: b"r\"", // idk about this
        }
        first_char: lower_case!() | uppercase!() | underscore!(),
        rest: alphanumeric!() | underscore!(),

        layout() -> {
            first_char rest
        }
    },

    punctuation: b'!'..=b'/'|b':'..=b'@'|b'['..=b'`'|b'{'..=b'~',

    //TODO: make work -> operators: two_char_operators!() | three_char_operators!()

    operators:  b"==" | b"!=" | b"<=" | b">=" | b"//" | b"**" |
    b"<<" | b">>" | b"r+" | b"r-"| b"r*" | b"r/" | b"r%" | b"r&" | b"r|" |
    b"r^" | b"+=" | b"-=" | b"*=" | b"/=" | b"%=" | b"&=" | b"|=" | b"^=" |
    b"=>" | b"@=" | b"->" | b"<-" | b"<=" | b">=" | b"&&" | b"--" |
    b"::" | b"||" | b"++"| b"?=" | b"===" | b"!==" | b"..." | b"r//" | b"r**" | b"r<<" | b"r>>" | b"//=" | b"**=" | b"<<=" |
    b">>=" | b"??" | b"|:"

    expression: {}


    operator:{
        assignment: {
            op:'=',
            type = "Binary",
            doc = "Assigns the value of the right operand to the left operand",
            precedence = 1,
            associativity = "Right to left",
            layout() -> {
                self::op
            }
        },
        equal_to: {
            op: "==",
            type = "Binary",
            doc = "Checks if the left operand is equal to the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        equal_to_location: {
            op: "===",
            type = "Binary",
            doc = "Checks if the location of the left operand is the same as the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        not_equal_to: {
            self: "!=",
            type = "Binary",
            doc = "Checks if the left operand is not equal to the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        greater_than: {
            op: ">",
            parent = super::expression,
            type = "Binary",
            doc = "Checks if the left operand is greater than the right operand",
            precedence = 3,
            associativity = "Left to right",
            layout() -> { self::op }

            assignment_layout -> { self::op super::expression }
        },
        less_than: {
            self: "<",
            rhs: super::expression,
            type = "Binary",
            doc = "Checks if the left operand is less than the right operand",
            precedence = 3,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        greater_than_or_equal_to: {
            self: ">=",
            type = "Binary",
            doc = "Checks if the left operand is greater than or equal to the right operand",
            precedence = 3,
            associativity = "Left to right",
        },
        less_than_or_equal_to: {
            self: "<=",
            type = "Binary",
            doc = "Checks if the left operand is less than or equal to the right operand",
            precedence = 3,
            associativity = "Left to right",
        },
        logical_and: {
            self: "&&",
            type = "Binary",
            doc = "Checks if both the left and right operands are true",
            precedence = 4,
            associativity = "Left to right",
        },
        logical_or: {
            self: "||",
            type = "Binary",
            doc = "Checks if either the left or right operand is true",
            precedence = 4,
            associativity = "Left to right",
        },
        logical_not: {
            self: "!",
            type = "Unary",
            doc = "Negates the value of the operand",
            precedence = 5,
            associativity = "Right to left",
        },
        bitwise_and: {
            self: "&",
            type = "Binary",
            doc = "Performs a bitwise AND operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_or: {
            self: "|",
            type = "Binary",
            doc = "Performs a bitwise OR operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_xor: {
            self: "^",
            type = "Binary",
            doc = "Performs a bitwise XOR operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_not: {
            self: "~",
            type = "Unary",
            doc = "Performs a bitwise NOT operation on the operand",
            precedence = 6,
            associativity = "Right to left",
        },
        shift_left: {
            self: "<<",
            type = "Binary",
            doc = "Shifts the bits of the left operand to the left by the number of bits specified by the right operand",
            precedence = 7,
            associativity = "Left to right",
        },
        shift_right: {
            self: ">>",
            type = "Binary",
            doc = "Shifts the bits of the left operand to the right by the number of bits specified by the right operand",
            precedence = 7,
            associativity = "Left to right",
        },
        add: {
            self: "+",
            type = "Binary",
            doc = "Adds the left and right operands",
            precedence = 8,
            associativity = "Left to right",
        },
        subtract: {
            self: "-",
            type = "Binary",
            doc = "Subtracts the right operand from the left operand",
            precedence = 8,
            associativity = "Left to right",
        },
        multiply: {
            self: "*",
            type = "Binary",
            doc = "Multiplies the left and right operands",
            precedence = 9,
            associativity = "Left to right",
        },
        divide: {
            self: "/",
            type = "Binary",
            doc = "Divides the left operand by the right operand",
            precedence = 9,
            associativity = "Left to right",
        },
        modulo: {
            self: "%",
            type = "Binary",
            doc = "Calculates the remainder of the left operand divided by the right operand",
            precedence = 9,
            associativity = "Left to right",
        },
        exponent: {
            self: "**",
            type = "Binary",
            doc = "Raises the left operand to the power of the right operand",
            precedence = 10,
            associativity = "Right to left",
        },
        increment: {
            self: "++",
            type = "Unary",
            doc = "Increments the value of the operand by 1",
            precedence = 11,
            associativity = "Right to left",
        },
        decrement: {
            self: "--",
            type = "Unary",
            doc = "Decrements the value of the operand by 1",
            precedence = 11,
            associativity = "Right to left",
        },







    }

        // TODO: name all of the

}

// TODO: Add this
#[derive(Debug, Clone)]
enum TokenType {
    String,
    Char,
    Numeric,
    Identifier,
    Delimiter,
    Operator,
    Comment,
    None,
}
// todo make ptr look up table for all match statements

// TODO: make a macro that converts the patten matching of rust to simd instructions
// so it looks like pattrn matching when using it in code, but its actually using simd instructions
