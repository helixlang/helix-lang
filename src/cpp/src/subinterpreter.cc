/**
 * @file subinterpreter_module.c
 * @brief Python C extension module for managing multiple Python
 * sub-interpreters.
 *
 * This file defines a Python C extension module named `subinterpreter` which
 * allows the creation, manipulation, and deletion of Python sub-interpreters.
 * The module provides three primary functions:
 * - `create_sub_interpreter`: Creates a new sub-interpreter and returns a
 * pointer to its thread state.
 * - `run_code`: Executes Python code in the specified sub-interpreter.
 * - `close_sub_interpreter`: Closes a previously created sub-interpreter and
 * cleans up its resources.
 *
 * The use of sub-interpreters can be beneficial in applications requiring
 * isolation between different execution environments within the same process,
 * such as in web servers running code for multiple clients in separate
 * interpreters to avoid cross-interaction through global variables.
 *
 * Each function is designed to handle the interpreter's lifecycle and ensure
 * thread safety by managing the Python thread state appropriately. Error
 * handling is incorporated to manage common issues such as file not found
 * errors or failure to create a new interpreter.
 *
 * This module exemplifies how to extend Python with C for performance-sensitive
 * or lower-level system interaction tasks, providing a robust interface for
 * managing multiple Python interpreters in a single process.
 *
 * @author Dhruvan Kartik
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 * @doc generated by ChatGPT
 * This work is licensed under the Creative Commons Attribution 4.0
 * International License. To view a copy of this license, visit
 * http://creativecommons.org/licenses/by/4.0/ or send a letter to Creative
 * Commons, PO Box 1866, Mountain View, CA 94042, USA.
 * @see http://creativecommons.org/licenses/by/4.0/
 */
// compile cmd: "c:\Programing Languages\LLVM\bin\gcc.exe" -Wall -shared -fPIC
// -I C:\Python312\include -o src/lib/subinterpreter.dll
// src/lib/src/subinterpreter.c -L C:\Python312\libs -lpython312
#include <Python.h>

static PyObject* create_sub_interpreter(PyObject *self, PyObject *args) {
    PyThreadState* interpreter_state = Py_NewInterpreter();
    if (interpreter_state == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to create new interpreter");
        return NULL;
    }
    return PyLong_FromVoidPtr(interpreter_state);
}

static PyObject* run_code(PyObject *self, PyObject *args) {
    PyThreadState* interpreter_state;
    const char* path_to_compiled_code;
    FILE* file;

    if (!PyArg_ParseTuple(args, "Ls", &interpreter_state, &path_to_compiled_code)) {
        return NULL;
    }

    PyThreadState* old_state = PyThreadState_Swap(interpreter_state);

    file = fopen(path_to_compiled_code, "r");
    if (file == NULL) {
        PyErr_SetString(PyExc_FileNotFoundError, "Cannot open file");
        PyThreadState_Swap(old_state);
        return NULL;
    }

    PyRun_SimpleFile(file, path_to_compiled_code);
    fclose(file);

    PyThreadState_Swap(old_state);

    Py_RETURN_NONE;
}


static PyObject* close_sub_interpreter(PyObject *self, PyObject *args) {
    PyThreadState* interpreter_state;

    if (!PyArg_ParseTuple(args, "L", &interpreter_state)) {
        return NULL;
    }

    PyThreadState_Swap(interpreter_state);
    Py_EndInterpreter(interpreter_state);

    Py_RETURN_NONE;
}

static PyMethodDef SubInterpreterMethods[] = {
    {"create_sub_interpreter", create_sub_interpreter, METH_NOARGS, "Create a new sub-interpreter"},
    {"run_code", run_code, METH_VARARGS, "Run code in a sub-interpreter"},
    {"close_sub_interpreter", close_sub_interpreter, METH_VARARGS, "Close a sub-interpreter"},
    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef subinterpretermodule = {
    PyModuleDef_HEAD_INIT,
    "subinterpreter",
    NULL,
    -1,
    SubInterpreterMethods
};

PyMODINIT_FUNC PyInit_subinterpreter(void) {
    return PyModule_Create(&subinterpretermodule);
}


// match [/]+.*
// \/\*(\*(?!\/)|[^*])*\*\/

