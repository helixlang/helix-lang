/**
 * @file panic.h
 * @brief Provides a unified panic handling interface for the Helix compiler,
 *        enabling enhanced error management and debugging capabilities across
 *        C++, Rust, and Python components.
 *
 * This header file is crucial for implementing robust error handling in the
 * Helix compiler. It facilitates the emission of detailed error messages and
 * supports aborting execution in a consistent and informative manner across
 * various programming environments integrated through the CXX bridge. The
 * definitions here are designed to be used extensively within the C++ parts of
 * the compiler but are tightly integrated with Rust and Python components,
 * ensuring that errors can be handled smoothly across language boundaries.
 *
 * Key Features:
 * - **Cross-Language Support:** Utilizes the CXX bridge to link C++ with Rust,
 *   which in turn can invoke Python functions. This cross-language setup allows
 *   for flexible and powerful error handling strategies that leverage the
 *   strengths of each language.
 * - **Platform-Specific Enhancements:** Contains implementations that adapt to
 *   different operating systems, such as Windows and UNIX-based systems, ensuring
 *   that file paths and system calls behave correctly across platforms.
 * - **Macro-Driven Interface:** Provides a range of macros designed to simplify
 *   the invocation of panic operations with various levels of detail, from simple
 *   messages to complex, annotated error reports that include file paths, line
 *   numbers, and threading information.
 *
 * Usage:
 *   Developers can use the provided macros to trigger error conditions in a
 *   standardized way. These macros ensure that all necessary context is included
 *   in error reports, such as file paths and line numbers, which are crucial for
 *   tracing back the origin of an issue.
 *
 * Examples:
 * ```cpp
 * // Simple panic with a message
 * panic("Unexpected null pointer");
 *
 * // Panic with an exception and a custom message
 * panic(std::exception("Failed to open file"));
 *
 * // Detailed panic with annotations to underline specific parts of the code in
 * the error output panic(std::exception("Invalid configuration"), {"[", "]"});
 * ```
 *
 * The output for these panics will include detailed information about the
 * location and nature of the error, thus aiding in quick diagnosis and
 * remediation.
 *
 * Implementation Details:
 * - The `panic_cpp_impl` function serves as the core implementation,
 *   interfacing directly with Rust's panic handling logic, which can then call
 *   Python's panic functions if needed.
 * - The macros expand to function calls that include default arguments like
 *   `__FILE__` and `__LINE__`, which capture the source file and line number from
 *   which the panic was triggered.
 *
 * @author Dhruvan Kartik
 * This work is licensed under the Creative Commons Attribution 4.0
 * International License. To view a copy of this license, visit
 * http://creativecommons.org/licenses/by/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 * @see http://creativecommons.org/licenses/by/4.0/
 *
 * You are free to:
 * - Share — copy and redistribute the material in any medium or format
 * - Adapt — remix, transform, and build upon the material
 * for any purpose, even commercially, under the following terms:
 * - Attribution — You must give appropriate credit, provide a link to
 *   the license, and indicate if changes were made. You may do so in
 *   any reasonable manner, but not in any way that suggests the licensor
 *   endorses you or your use.
 *
 * This is a human-readable summary of (and not a substitute for) the license.
 * For the full license text, see the LICENSE file in the root directory of
 * this source code repository or visit the URL above.
 *
 * @see src/python/src/panic.py for the Python layer implementation details.
 * @see src/rust/mod.rs for how Rust interfaces with the Python panic function.
 * @doc generated by ChatGPT
 */
#ifndef PANIC_H
#define PANIC_H

#include <cstddef>
#include <string>
#include <cstring>
#include "rust/cxx.h"
#include <type_traits>
#include <exception>
#include <iostream>
#include <cstdlib>

#if defined(_WIN32)
    #include <direct.h>
    #define GETCWD _getcwd
    #define PATH_SEPARATOR "\\"
#else
    #include <unistd.h>
    #define GETCWD getcwd
    #define PATH_SEPARATOR "/"
#endif

#ifndef PATH_MAX
    #define PATH_MAX 260
#endif

inline const char* abs_path(const char* filename) {
    char buffer[PATH_MAX];
    auto val = GETCWD(buffer, PATH_MAX)
             ? std::string{std::string(buffer) + PATH_SEPARATOR + filename}
             : std::string{filename};

    for (int i = 0; i < val.size(); i++) {
        if (val.data()[i] == '\\' || val.data()[i] == '/') {
            val.data()[i] = PATH_SEPARATOR[0];
        }
    }

    char* result = new char[val.size() + 1];
    strcpy_s(result, val.size() + 1, val.c_str());
    return result;
}

inline std::string format_error_message(const char* msg) {
    return std::string(msg);
}

inline std::string format_error_message(const std::exception& e) {
    const char* e_type = typeid(e).name();
    if (std::strncmp(e_type, "class ", 6) == 0) e_type += 6;
    return std::string(e_type) + "%^%*%#~^#%%%" + e.what();
}

extern void panic_cpp_impl(
    rust::Str _error, rust::Slice<const rust::Str> mark,
    rust::Str _file, int line_no, bool no_lines,
    bool multi_frame, int8_t pos,
    bool follow_marked_order, uint32_t mark_start,
    rust::Str thread_name, bool no_exit, rust::Str lang,
    rust::Str _code
) noexcept;

template <typename T>
inline void panic_wrapper(
        T           _error, rust::Slice<const rust::Str> mark,
        rust::Str   _file, // = abs_path(__FILE__),
        int         line_no,     // = __LINE__,
        bool        no_lines = false, bool multi_frame = false,
        int8_t      pos = 0, bool follow_marked_order = false,
        uint32_t    mark_start = 0, rust::Str thread_name = "",
        bool        no_exit = false, rust::Str lang = "cpp",
        rust::Str   _code = ""
    ) noexcept {
    panic_cpp_impl(format_error_message(_error), mark, _file,
                   line_no, no_lines, multi_frame, pos, follow_marked_order,
                   mark_start, thread_name, no_exit, lang, _code);
    std::exit(369);
}

/* --------===========----------- PANIC MACROS ----===========--------------- */
#define PANIC(err) panic_wrapper(err, {}, abs_path(__FILE__), __LINE__)
#define PANIC_MARKED(err, focus)                                               \
    panic_wrapper(err, focus, abs_path(__FILE__), __LINE__)
#define PANIC_CUSTOM_LOC_1(err, focus, file)                                   \
    panic_wrapper(err, focus, file, __LINE__)
#define PANIC_CUSTOM_LOC_2(err, focus, file, line_num)                         \
    panic_wrapper(err, focus, file, line_num)
#define PANIC_CUSTOM_WITH_TRACE(E, focus, file, line_num, no_lines,            \
                                multi_frame, pos, follow_marked_order,         \
                                mark_start, thread_name, no_exit, lang, code)  \
    panic_wrapper(E, focus, file, line_num, no_lines, multi_frame, pos,        \
                  follow_marked_order, mark_start, thread_name, no_exit, lang, \
                  code)
#define PANIC_THREADED(E, thread_name)                                         \
    panic_wrapper(E, {}, abs_path(__FILE__), __LINE__, false, false, 0, false, \
                  0, thread_name, false, "cpp", "")
#define PANIC_THREADED_MARKED(E, focus, thread_name)                           \
    panic_wrapper(E, focus, abs_path(__FILE__), __LINE__, false, false, 0,     \
                  false, 0, thread_name, false, "cpp", "")
/* ===========-------------------- Count Args --------------------=========== */
#define COUNT_ARGS(...)                                                        \
    COUNT_ARGS_IMPL(__VA_ARGS__, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
#define COUNT_ARGS_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, N,  \
                        ...)     N
/*=======----------------------- Choose Macro -----------------------=========*/
#define PANIC_CHOOSE_HELPER2(count) PANIC_##count
#define PANIC_CHOOSE_HELPER1(count) PANIC_CHOOSE_HELPER2(count)
#define PANIC_CHOOSE_MACRO(...)     PANIC_CHOOSE_HELPER1(COUNT_ARGS(__VA_ARGS__))
/*=========--------------------- Panic Macro ----------------------===========*/
#define PANIC_1(err) PANIC(err)
#define PANIC_2(err, focus_or_thread_name)                                     \
    (sizeof(focus_or_thread_name) == sizeof(char *)                            \
        ? PANIC_THREADED(err, focus_or_thread_name)                            \
        : PANIC_MARKED(err, focus_or_thread_name))
#define PANIC_3(err, focus, file) PANIC_CUSTOM_LOC_1(err, focus, file)
#define PANIC_4(err, focus, file, line_num)                                    \
    PANIC_CUSTOM_LOC_2(err, focus, file, line_num)
#define PANIC_5(E, thread_name) PANIC_THREADED(E, thread_name)
#define PANIC_6(E, focus, thread_name)                                         \
    PANIC_THREADED_MARKED(E, focus, thread_name)
#define PANIC_12(E, focus, file, line_num, no_lines, multi_frame, pos,         \
                 follow_marked_order, mark_start, thread_name, no_exit, lang,  \
                 code)                                                         \
    PANIC_CUSTOM_WITH_TRACE(E, focus, file, line_num, no_lines, multi_frame,   \
                            pos, follow_marked_order, mark_start, thread_name, \
                            no_exit, lang, code)
/*==========----------------------- Panic ------------------------============*/
#define panic(...) PANIC_CHOOSE_MACRO(__VA_ARGS__)(__VA_ARGS__)

#endif // PANIC_H