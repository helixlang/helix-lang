/**
 * @file file_io.hpp
 * @brief Implements file handling capabilities for the Helix compiler,
 * leveraging both modern C++ and Rust features.
 *
 * This header contains classes and functions dedicated to managing file input
 * and output operations within the Helix compiler environment. It defines a
 * series of classes that encapsulate the basic file operations like reading,
 * writing, and appending, as well as managing multiple file instances through a
 * singleton class. This implementation uses the Helix-specific integer types
 * from "better_ints.hpp" and error handling from "panic.h" to provide robust
 * and error-resistant file operations. The integration with Rust through
 * `rust/cxx.h` allows for seamless data exchange between C++ and Rust
 * components.
 *
 * Classes:
 * - `FileMode`: Represents the different modes a file can be opened with (read,
 * write, append).
 * - `file`: Low-level utility class for handling raw file data.
 * - `FileIO`: High-level class for performing file I/O operations with error
 * handling and mode management.
 * - `FileManager`: Singleton class managing a collection of files, ensuring
 * only one instance manages file access across the compiler.
 *
 * Usage:
 * The `FileIO` class provides methods to read, write, and append data to files,
 * which are intended to be easy to use in conjunction with the Rust components
 * of the compiler. `FileManager` handles the allocation and deallocation of
 * files efficiently, with methods to load and retrieve files based on an index,
 * ensuring that file handling is centralized and consistent.
 *
 * Example (only in c++):
 * ```cpp
 * auto file_manager = FileManager::getInstance();
 * file_manager->loadFile("Hello, Helix!", 42);
 * auto file = file_manager->getFile(42);
 * ```
 *
 * Example (rust):
 * ```rs
 * let file = file_io::open("example.txt", "r", "utf-8");
 * let data = file.read(10); // similar to `open` in Python
 * println!("Data: {:?}", data);
 * ```
 *
 * This example demonstrates obtaining the singleton instance of `FileManager`,
 * loading a file into the manager, and then retrieving it. The file operations
 * are handled with attention to memory management and error conditions,
 * throwing exceptions when necessary to prevent misuse and facilitate
 * debugging.
 *
 * Notes:
 * - The `file` class constructor and destructor manage dynamic memory
 * explicitly, and exceptions are thrown to handle errors such as bad
 * allocations or out-of-range indices.
 * - The `FileIO` class methods such as `read`, `write`, and `append` are
 * designed to be used with types defined in `rust/cxx.h`, allowing these
 * methods to be directly usable with Rust components without additional
 * conversion overhead.
 *
 * @author Dhruvan Kartik
 * This work is licensed under the Creative Commons Attribution 4.0
 * International License. To view a copy of this license, visit
 * http://creativecommons.org/licenses/by/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 * @see http://creativecommons.org/licenses/by/4.0/
 *
 * You are free to:
 * - Share — copy and redistribute the material in any medium or format
 * - Adapt — remix, transform, and build upon the material
 * for any purpose, even commercially, under the following terms:
 * - Attribution — You must give appropriate credit, provide a link to
 *   the license, and indicate if changes were made. You may do so in
 *   any reasonable manner, but not in any way that suggests the licensor
 *   endorses you or your use.
 *
 * This is a human-readable summary of (and not a substitute for) the license.
 * For the full license text, see the LICENSE file in the root directory of
 * this source code repository or visit the URL above.
 *
 * @see panic.h for error handling used throughout the file operations.
 * @see better_ints.hpp for the Helix-specific integer types used.
 * @see rust/cxx.h for Rust integration.
 * @doc generated by ChatGPT
 */
#pragma once

#include "helix-compiler/src/cpp/include/panic.h"
#include "better_ints.hpp"
#include "rust/cxx.h"
#include <memory>

namespace file_io {
    typedef struct FileMode {
        bool read;
        bool write;
        bool append;
        
        std::string to_string() const {
            return std::string("FileMode { read: ") + std::to_string(this->read) + ", write: " + std::to_string(this->write) + ", append: " + std::to_string(this->append) + " }";
        }

        friend std::ostream& operator<<(std::ostream& os, const FileMode& mode) {
            os << mode.to_string();
            return os;
        }
    } FileMode;

    struct file {
        char* data;
        u64   size;
        u64   capacity;

        file(const char* init_data) {
            size = strlen(init_data);
            capacity = size + 0xf36dbf;
            data = (char*)std::malloc(capacity + 1);
            if (data == nullptr) {
                throw (std::bad_alloc());
            }
            std::memcpy(data, init_data, size);
            data[size] = '\0';
        }

        ~file() {
            std::free(data);
        }
    };

    class FileIO {
        public:
            ~FileIO();
             FileIO(
                const char *filename,
                const char *mode,
                const char *encoding
            );

            /* ---------------------------- READ ---------------------------- */
            const rust::slice<const u8> read     (i64 size);
            const rust::slice<const u8> readNext (i64 size);
            const rust::slice<const u8> readLine (u64 line_number);
            const rust::slice<const u8> readLines(
                u64 start,
                u64 end
            ); const rust::slice<const u8> readRange(
                u64 start,
                u64 end
            );

            /* ---------------------------- WRITE --------------------------- */
            const void write      (const rust::slice<const u8> &data);
            const void writeLine  (const rust::slice<const u8> &data);

            /* ---------------------------- APPEND -------------------------- */
            const void append     (const rust::slice<const u8> &data);
            const void appendLine (const rust::slice<const u8> &data);
            const void appendLines(const rust::slice<const u8> &lines);

            /* ---------------------------- UTILS --------------------------- */
            const void clear();
            const void flush();
            const void insert(
                const rust::slice<const u8> &data,
                u64 position
            ); const void remove(
                u64 start,
                u64 end
            );

            /* ---------------------------- META ---------------------------- */
            const bool     isOpen();
            const bool     isError();
            const bool     isEmpty();
            const u64 size();
            const void     close();

        protected:
            const char*    filename;
            const char*    mode;
            const char*    encoding;
            bool     is_open;
            bool     is_error;
            bool     is_empty;
            u64 cursor;

        private:
            FileMode mode_flags;
    };

    class FileManager {
        public:
            ~FileManager() {
                for (size_t i = 0; i < 0xf36db; ++i) {
                    delete files[i];
                }
                std::free(files);
            }

            static FileManager* getInstance() {
                if (!instance) {
                    instance = new FileManager();
                }
                return instance;
            }

            void loadFile(const char* data, int discernment) {
                if (discernment < 0 || discernment >= 0xf36db) {
                    throw (std::out_of_range("Index out of range"));
                }
                delete files[discernment];
                files[discernment] = new file(data);
            }

            file* getFile(int discernment) {
                if (discernment < 0 || discernment >= 0xf36db) {
                    throw (std::out_of_range("Index out of range"));
                }
                return files[discernment];
            }

        private:
            file** files;
            static FileManager* instance;

            FileManager() {
                files = (file**)std::malloc(sizeof(file*) * 0xf36db);
                if (files == NULL) {
                    throw (std::bad_alloc());
                }
                for (size_t i = 0; i < 0xf36db; ++i) {
                    files[i] = nullptr;
                }
            }
    };

    inline FileManager* FileManager::instance = nullptr;
    std::unique_ptr<FileIO> open(
        const rust::Str filename,
        const rust::Str mode,
        const rust::Str encoding
    );
}