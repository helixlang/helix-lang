import threading
from _typeshed import Incomplete
from argparse import Namespace
from classes.Scope import Scope
from classes.Token import Processed_Line as Processed_Line, Token_List as Token_List
from types import ModuleType
from typing import Any, Callable, Iterable, Optional

__version__: str
USE_CACHE: bool
bar_thread: Incomplete

class Hashing:
    def __init__(self, file_path: str, output_path: str) -> None: ...
    def __int__(self) -> int: ...
    @staticmethod
    def compute_hash(code: str) -> bytes: ...
    def create_hash_only(self) -> None: ...
    @staticmethod
    def get_mount(path): ...
    def create_file(self, code: str) -> None: ...
    def is_code_altered(self) -> bool: ...
    def get_hash(self) -> bytes | None: ...

def watch_processes() -> None: ...

class ThreadedProcess:
    __processes_queue__: dict[int, threading.Thread]
    def __new__(cls, func: Callable[..., None]): ...
    __func__: Incomplete
    def __init__(self, func: Callable[..., None]) -> None: ...
    __pid__: Incomplete
    __thread__: Incomplete
    def __call__(self, *args, **kwargs) -> None: ...
    @property
    def processes(self) -> dict[int, threading.Thread]: ...

class ArgParser:
    def help_screen(self) -> None: ...
    def version_screen(self) -> None: ...
    __args__: Incomplete
    def __init__(self, argv: Optional[Iterable[str]] = None) -> None: ...
    @property
    def args(self) -> Namespace: ...

class HelixLanguage:
    def __init__(self, *args: str, **kwargs: str) -> None: ...
    @staticmethod
    def make_folder(directory: str) -> None: ...
    @staticmethod
    def make_file(file: str) -> None: ...
    @staticmethod
    def generate_folder_structure(directory: str = ...): ...
    @staticmethod
    def install_helix(config: dict) -> None: ...

class Timer:
    def __init__(self) -> None: ...
    def start(self, name: str) -> None: ...
    def end(self, name: str) -> None: ...
    def get_time(self, name: str) -> float: ...
    def decorator(self, func: Callable) -> Callable: ...

class DisabledKeyboardInterrupt:
    signal_received: Incomplete
    old_handler: Incomplete
    def __enter__(self) -> None: ...
    def handler(self, sig: int, frame: Any) -> None: ...
    def __exit__(self, type: Any, value: Any, traceback: Any) -> None: ...

class Helix:
    config: Namespace
    @classmethod
    def interpreter(cls, code: str, globals_: dict, locals_: dict) -> str: ...
    def build_path(self) -> str: ...
    def remove_blank_lines(self, file: str, hash: Hashing | None) -> None: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...
    def __del__(self) -> None: ...
    def __delattr__(self, name) -> None: ...
    profile: Incomplete
    import_: Incomplete
    timer: Incomplete
    __config_file__: Incomplete
    __args__: Incomplete
    __argv__: Incomplete
    __format_out__: bool
    __out_file__: Incomplete
    __file_hash__: Incomplete
    def __init__(self, conf_file: Optional[str] = None, *args: str, profile: bool = False, import_: bool = False) -> None: ...
    @classmethod
    def factory(cls, config_file: str, *args: str, **kwargs: Any) -> None: ...
    def run(self) -> None: ...
    def cleanup(self) -> None: ...
    def compile_file(self, file: Optional[str] = None) -> Scope: ...
    def transpile(self, file: Optional[str] = None) -> tuple[Scope, list[Processed_Line]]: ...
    def generate_line_numbers(self, transpiled: list[Processed_Line]) -> str: ...
    def generate_source_code(self, scope_parsed: Scope, transpiled_lines: list[Processed_Line], format_source: bool = False, is_main: bool = True, no_inject: bool = False) -> str: ...
    def inject_core(self, code: Optional[str] = None, is_main: bool = True) -> str: ...
    @staticmethod
    def REPL() -> None: ...
    @classmethod
    def __hook_import__(cls, file: str, *args: str, config_file: Optional[str] = None, **kwargs: Any) -> ModuleType: ...
