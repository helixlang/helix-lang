// -*- C++ -*-
//===------------------------------------------------------------------------------------------===//
//
// Part of the Helix Project, under the Attribution 4.0 International license (CC BY 4.0).
// You are allowed to use, modify, redistribute, and create derivative works, even for commercial
// purposes, provided that you give appropriate credit, and indicate if changes were made.
// For more information, please visit: https://creativecommons.org/licenses/by/4.0/
//
// SPDX-License-Identifier: CC-BY-4.0
// Copyright (c) 2024 (CC BY 4.0)
//
//===------------------------------------------------------------------------------------------===//

#ifndef __HELPERS_DEF__
#define __HELPERS_DEF__

#include <stdnoreturn.h>

#include "token/include/token.hh"
#include "token/include/token_list.hh"

#define LITERALS                                     \
    token::LITERAL_TRUE : case token::LITERAL_FALSE: \
    case token::LITERAL_INTEGER:                     \
    case token::LITERAL_COMPLIER_DIRECTIVE:          \
    case token::LITERAL_FLOATING_POINT:              \
    case token::LITERAL_STRING:                      \
    case token::LITERAL_CHAR:                        \
    case token::LITERAL_NULL

#define OPERATORS                                   \
    token::OPERATOR_ADD : case token::OPERATOR_SUB: \
    case token::OPERATOR_MUL:                       \
    case token::OPERATOR_DIV:                       \
    case token::OPERATOR_MOD:                       \
    case token::OPERATOR_MAT:                       \
    case token::OPERATOR_BITWISE_AND:               \
    case token::OPERATOR_BITWISE_OR:                \
    case token::OPERATOR_BITWISE_XOR:               \
    case token::OPERATOR_BITWISE_NOT:               \
    case token::OPERATOR_ASSIGN:                    \
    case token::OPERATOR_LOGICAL_NOT:               \
    case token::OPERATOR_POW:                       \
    case token::OPERATOR_ABS:                       \
    case token::OPERATOR_BITWISE_L_SHIFT:           \
    case token::OPERATOR_BITWISE_NAND:              \
    case token::OPERATOR_BITWISE_R_SHIFT:           \
    case token::OPERATOR_BITWISE_NOR:               \
    case token::OPERATOR_EQUAL:                     \
    case token::OPERATOR_NOT_EQUAL:                 \
    case token::OPERATOR_GREATER_THAN_EQUALS:       \
    case token::OPERATOR_INC:                       \
    case token::OPERATOR_DEC:                       \
    case token::OPERATOR_LESS_THAN_EQUALS:          \
    case token::OPERATOR_ADD_ASSIGN:                \
    case token::OPERATOR_SUB_ASSIGN:                \
    case token::OPERATOR_MUL_ASSIGN:                \
    case token::OPERATOR_BITWISE_AND_ASSIGN:        \
    case token::OPERATOR_BITWISE_OR_ASSIGN:         \
    case token::OPERATOR_BITWISE_NOR_ASSIGN:        \
    case token::OPERATOR_BITWISE_XOR_ASSIGN:        \
    case token::OPERATOR_BITWISE_NOT_ASSIGN:        \
    case token::OPERATOR_DIV_ASSIGN:                \
    case token::OPERATOR_MOD_ASSIGN:                \
    case token::OPERATOR_MAT_ASSIGN:                \
    case token::OPERATOR_LOGICAL_AND:               \
    case token::OPERATOR_LOGICAL_NAND:              \
    case token::OPERATOR_LOGICAL_OR:                \
    case token::OPERATOR_LOGICAL_NOR:               \
    case token::OPERATOR_LOGICAL_XOR:               \
    case token::OPERATOR_RANGE:                     \
    case token::OPERATOR_ARROW:                     \
    case token::OPERATOR_NOT_ASSIGN:                \
    case token::OPERATOR_SCOPE:                     \
    case token::OPERATOR_REF_EQUAL:                 \
    case token::OPERATOR_POWER_ASSIGN:              \
    case token::OPERATOR_AND_ASSIGN:                \
    case token::OPERATOR_NAND_ASSIGN:               \
    case token::OPERATOR_OR_ASSIGN:                 \
    case token::OPERATOR_NOR_ASSIGN:                \
    case token::OPERATOR_XOR_ASSIGN:                \
    case token::OPERATOR_BITWISE_NAND_ASSIGN:       \
    case token::OPERATOR_BITWISE_L_SHIFT_ASSIGN:    \
    case token::OPERATOR_BITWISE_R_SHIFT_ASSIGN:    \
    case token::OPERATOR_RANGE_INCLUSIVE:           \
    case token::PUNCTUATION_OPEN_ANGLE:             \
    case token::PUNCTUATION_CLOSE_ANGLE

namespace parser::ast::node {
using namespace token;

noreturn inline void is_tokens_empty() {
    throw std::runtime_error("get_expr: failed, consumer was empty.");
}

inline bool is_literal(const token::Token &tok) {
    switch (tok.token_kind()) {
        case LITERALS:
            return true;

        default:
            break;
    }

    return false;
}

inline bool is_op(const token::Token &tok) {
    switch (tok.token_kind()) {
        case OPERATORS:
            return true;

        case token::OTHERS:
            for (auto &chr : tok.value()) {
                switch (Token(0, 0, 0, 0, std::string(1, chr), "").token_kind()) {
                    case OPERATORS:
                        break;  // valid
                    default:
                        return false;  // invalid
                }
            }

            return true;

        default:
            break;
    }

    return false;
}

inline bool is_qualified_namespace_path(TokenList &tokens) {
    // QualifiedNamespaceID ::= Identifier ('::' Identifier)*

    if (tokens.empty()) [[unlikely]] {
        is_tokens_empty();
    }

    if (tokens[0] != tokens::IDENTIFIER) {
        return false;
    }

    if (tokens.size() < 1) {
        return false;
    }

    if (tokens[1] != tokens::OPERATOR_SCOPE) {
        return false;
    }

    // at this point we has satisfied 1/3;

    for (auto &tok : tokens.slice(1)) {
        if (tok.current().get() != tokens::OPERATOR_SCOPE) {
            break;
        }

        tok.advance();

        if (tok.current().get() != tokens::IDENTIFIER) {
            return false;  // this has to be an identifier
        }
    }

    return true;
}

inline bool is_dot_separated_path(TokenList &tokens) {
    // QualifiedNamespaceID ::= Identifier ('::' Identifier)*

    if (tokens.empty()) [[unlikely]] {
        is_tokens_empty();
    }

    if (tokens[0] != tokens::IDENTIFIER) {
        return false;
    }

    if (tokens.size() < 1) {
        return false;
    }

    if (tokens[1] != tokens::PUNCTUATION_DOT) {
        return false;
    }

    // at this point we has satisfied 2/3;

    for (auto &tok : tokens.slice(1)) {
        if (tok.current().get() != tokens::PUNCTUATION_DOT) {
            break;
        }

        tok.advance();

        if (tok.current().get() != tokens::IDENTIFIER) {
            return false;  // this has to be an identifier
        }
    }

    return true;
}

}  // namespace parser::ast::node

#endif  // __HELPERS_DEF__