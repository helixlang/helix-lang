
/* Main Program Structure */

Program            ::= (ImportStatement | PreprocessorDirective | VariableDeclaration | FunctionDefinition | Statement)*

/* Module Importing */

ImportStatement    ::= 'import' QualifiedNamespaceID ('::' '{' (QualifiedNamespaceID (',' QualifiedNamespaceID)*) '}')? ('as' QualifiedNamespaceID)? ';'

FFIImportStatement ::= 'ffi' String ImportStatement

/* Preprocessor Directives */

PreprocessorDirective ::= DefineMacro | ProcMacro

DefineMacro           ::= 'define' Identifier ('(' (UntypedParameter (',' UntypedParameter)*)? ')')? Suite ';'

ProcMacro             ::= 'macro' Identifier '(' (TypedParameter (',' TypedParameter)*)? ')' '->' Type '{' (Statement | Expression) '}' ';'

/* Control Flow */

ForLoop           ::= 'for' '(' (CStyleForLoop | PyStyleForLoop) ')' | (CStyleForLoop | PyStyleForLoop) Suite

CStyleForLoop     ::= (VariableDeclaration | Expression?) ';' Expression? ';' Expression?

PyStyleForLoop    ::= AnySeparatedID (':' Type)? 'in' Expression

WhileLoop         ::= 'while' Expression Suite

IfStatement       ::= ('if' | 'unless') Expression Suite

ElseIfStatement   ::= 'else' ('if' | 'unless') Expression Suite

ElseStatement     ::= 'else' Suite

ContinueStatement ::= 'continue'

BreakStatement ::= 'break'
 
SwitchStatement ::= 'switch' '{' ((('case' Expression) | 'default') Suite)* '}'

MatchExpression ::= 'match' '{' ((Expression | '_') '->' (CodeBlock | (':' Expression)) (',' (Expression | '_') '->' (CodeBlock | (':' Expression)))*) '}'

/* Functions and Methods */
FunctionDecl ::= 'fn' QualifiedNamespaceID '(' (TypedParameter (',' TypedParameter)*)? (DefaultArgument (',' DefaultArgument)*)? ')' ('->' Type)?

FunctionDefinition ::= BaseObjectDecl FunctionDecl GenericDeclaration? (Suite | ';')

OperatorDefinition ::= 'op' Operator 'as' FunctionDecl (Suite | ';')

ReturnExpression ::= 'return' (Expression)? ';'

YieldExpression ::= 'yield' (Expression)? ';'

/* Class and Struct */

BaseObjectDecl ::= AccessModifiers? (('inline' ('static' | 'const')?) | 'async' | 'static' | 'const' | 'final' | FFIAccess)

ClassDefintion ::= BaseObjectDecl  'class'  QualifiedNamespaceID (('derives' | ':') (QualifiedNamespaceID (',' QualifiedNamespaceID)*))? GenericDeclaration? (Suite | ';')

EnumDefintion  ::= BaseObjectDecl  'enum'   QualifiedNamespaceID (('{' ((TypedParameter | UntypedParameter) ('=' Expression)? (';' (TypedParameter | UntypedParameter) ('=' Expression)?)*) '}') | ';')

StructDefintion ::= BaseObjectDecl 'struct' GenericDeclaration? (Suite | ';')

UnionDefintion ::= BaseObjectDecl  'union' GenericDeclaration? (('{' ((TypedParameter | UntypedParameter) (';' (TypedParameter | UntypedParameter))*) '}') | ';')

TypeDefintion ::= 

/* Variable Declarations */
VariableDeclaration ::= AccessModifiers? 'let' (
    (('unsfae')? ('final' | 'atomic' | 'shared')? (TypedParameter | UntypedParameter) ('=' Expression)?)
    | ('const' (TypedParameter) '=' Expression)
) ';'

/* Type Definitions */

GenericAccess    ::= '<' ((QualifiedNamespaceID | Literal) (',' (QualifiedNamespaceID | Literal))*)? '>'

TypeBound ::= UntypedParameter is (QualifiedNamespaceID GenericAccess? ('&' QualifiedNamespaceID GenericAccess?)*)

GenericType ::= (('const' TypedParameter) | UntypedParameter) ('=' Expression)?

GenericDeclaration ::= 'requires' '<' (GenericType (',' GenericType)*)? '>' ('if' TypeBound (',' TypeBound)*)?

TupleType        ::= '(' (Type (',' Type)*) ')'

Type             ::= ('int' | 'float' | 'decimal' | 'string' | 'char' | 'bool'
                   | 'list' GenericAccess | 'map' GenericAccess | 'set' GenericAccess
                   | 'tuple' GenericAccess | 'void'
                   | 'i8' | 'i16' | 'i32' | 'i64' | 'i128'
                   | 'u8' | 'u16' | 'u32' | 'u64' | 'u128'
                   | 'f32' | 'f64' | QualifiedNamespaceID GenericAccess?) | TupleType (('*' | '&')? ('?'))?

/* Operators */

Operator         ::= '+'   | '-'   | '*'   | '/'   | '%'   | '@'   | '&'
                   | '^'   | '~'   | '='   | '!'   | '**'  | '+-'  | '<<'
                   | '~&'  | '>>'  | '~|'  | '=='  | '!='  | '>='  | '++'
                   | '--'  | '<='  | '+='  | '-='  | '*='  | '&='  | '|='
                   | '~|'  | '^='  | '~='  | '/='  | '%='  | '@='  | '&&'
                   | '!&'  | '||'  | '!|'  | '^^'  | '..'  | '->'  | '~='
                   | '|'   | '::'  | '===' | '**=' | '&&=' | '!&=' | '||='
                   | '!|=' | '^^=' | '~&=' | '<<=' | '>>=' | '..=' | [^a-zA-Z0-9_]+

/* Expressions */

Expression       ::= Literal | AnySeparatedID | BinaryOperation | UnaryOperation | FunctionCall | ParenthesizedExpression | ArrayAccess | ObjectAccess | ConditionalExpression

BinaryOperation  ::= Expression Operator Expression

UnaryOperation   ::= Operator Expression

FunctionCall     ::= AnySeparatedID GenericAccess? '(' (Expression (',' Expression)*)? ')'

ParenthesizedExpression ::= '(' Expression ')'

ArrayAccess     ::= AnySeparatedID '[' Expression ']'

ObjectAccess    ::= AnySeparatedID '.' Identifier

ConditionalExpression ::= Expression '?' Expression ':' Expression

/* Statements */

Assignment           ::= AnySeparatedID '=' Expression ';'

Statement            ::= VariableDeclaration | Assignment | Expression ';' | ControlFlowStatement | ReturnExpression | YieldExpression | BlockStatement

ControlFlowStatement ::= ForLoop | WhileLoop | IfStatement | UnlessStatement | ElseIfStatement | ElseStatement | ContinueStatement | BreakStatement | SwitchStatement | MatchExpression

BlockStatement       ::= Suite

Statements           ::= Statement*

/* Code Structure */

CodeBlock ::= '{' (Statements | Expressions) '}'

CodeLine ::= ':' (Statement | Expression) ';'

Suite ::= CodeLine | CodeBlock

FFIAccess ::= 'ffi' String

TypedParameter   ::= Identifier ':' Type

UntypedParameter ::= Identifier

AccessModifiers ::= 'priv' | 'pub' | 'prot' | 'intl'

QualifiedNamespaceID ::= Identifier ('::' Identifier)*

DotSeparatedID   ::= Identifier ('.' Identifier)*

AnySeparatedID   ::= (DotSeparatedID | QualifiedNamespaceID) (DotSeparatedID | QualifiedNamespaceID)*

/* Base Elements */

Literal          ::= Number | String | 'true' | 'false' | 'null' | 'nullptr'

Number           ::= Digit+ ('.' Digit+)?

String           ::= '"' [^"]* '"' | "'" [^']* "'"

Identifier       ::= [A-Za-z_][A-Za-z0-9_]*

Digit            ::= [0-9]

/* Default Argument */

DefaultArgument  ::= TypedParameter '=' Expression
