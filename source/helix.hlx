//===----------------------------------------- Helix -----------------------------------------====//
//                                                                                                //
//  Part of the Helix Project, under the Attribution 4.0 International license (CC BY 4.0).       //
//  You are allowed to use, modify, redistribute, and create derivative works, even for           //
//  commercial purposes, provided that you give appropriate credit, and indicate if changes       //
//   were made. For more information, please visit: https://creativecommons.org/licenses/by/4.0/  //
//                                                                                                //
//  SPDX-License-Identifier: CC-BY-4.0                                                            //
//  Copyright (c) 2024 (CC BY 4.0)                                                                //
//                                                                                                //
//====----------------------------------------------------------------------------------------====//
//                                                                                                //
// this is the drop in replacement for the entire Helix compiler, this will be used when          //
// rewriting the compiler in helix itself (self-hosting), the reason this is the entry point is   //
// helix the compiler can now work with the c++ interop modules rather then having to compile     //
// only helix files into c++ headers then include them, instead we can now just use bi-directional//
// ffi to include c++ headers and use them in helix code.                                         //
//                                                                                                //
//====----------------------------------------------------------------------------------------====//

ffi "c++" import "controller/include/config/Controller_config.def";
ffi "c++" import "controller/include/shared/file_system.hh";
ffi "c++" import "llvm/Support/CodeGen.h";

macro _SILENCE_CXX23_ALIGNED_UNION_DEPRECATION_WARNING;
macro _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;
macro _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS;

eval if (defined(MSVC)) {
    #[pragma(comment(linker, "/STACK:2000000000"))];  // Set stack size to 2MB
    #[pragma(comment(linker, "/HEAP:2000000000"))];   // Set heap size to 2MB
}

ffi "c++" import "chrono";
ffi "c++" import "cstdlib";
ffi "c++" import "vector";

ffi "c++" import "controller/include/Controller.hh";
ffi "c++" import "generator/include/CX-IR/CXIR.hh";
ffi "c++" import "lexer/include/lexer.hh";
ffi "c++" import "neo-panic/include/error.hh";
ffi "c++" import "neo-pprint/include/hxpprint.hh";
ffi "c++" import "parser/ast/include/AST.hh";
ffi "c++" import "parser/cpp/fn_signatures.hh";
ffi "c++" import "parser/preprocessor/include/preprocessor.hh";
ffi "c++" import "token/include/Token.hh";

fn compile_CXIR(emitter: &generator::CXIR::CXIR, const out: &std::string, is_debug: bool = false) {
    /// compile the c++ using an in-memory buffer and invoke clang++
    let cxx: std::string = emitter.to_CXIR();
    let path = std::filesystem::path(__CONTROLLER_FS_N::get_cwd());
    let file = std::ofstream(path / "_H1HJA9ZLO_17.helix-compiler.cc");
    
    finally: std::filesystem::remove(path / "_H1HJA9ZLO_17.helix-compiler.cc");

    if !file {
        print("error creating _H1HJA9ZLO_17.helix-compiler.cc file");
        return;
    }

    file << cxx;
    file.close();

    let cmd: std::string = std::string("c++ -std=c++23 ") + (is_debug ? "-g" : "") +
                        " -O0 -fno-omit-frame-pointer -Wl,-w,-rpath,/usr/local/lib " +
                        (path / "_H1HJA9ZLO_17.helix-compiler.cc").string() + " -o " + (path / out).string();

    let compileCommand: const *char = cmd.c_str();

    if system(compileCommand) != 0 {
        print("compilation failed");
        return;
    }

    std::cout << "compiled to " << path / out << std::endl;
}

fn compile(argc: int, argv: **char) -> int {
    // relative to current working dir in POSIX shell (cmd/bash)
    let parsed_args = __CONTROLLER_CLI_N::CLIArgs(argc, argv, "0.0.1-alpha-2012");
    check_exit(parsed_args);

    if parsed_args.verbose {
        print(parsed_args.get_all_flags);
    }

    let start = std::chrono::high_resolution_clock::now();

    let in_file_path = __CONTROLLER_FS_N::normalize_path(parsed_args.file);

    // read the file and tokenize its contents : stage 0
    print("tokenizing...", sysIO::endl('\r'));
    
    let file = __CONTROLLER_FS_N::read_file(in_file_path);
    let lexer = parser::lexer::Lexer(file, in_file_path);
    let tokens: __TOKEN_N::TokenList = lexer.tokenize();

    let pkg_paths: std::vector<string> = {"/Volumes/Container/Projects/Helix/helix-lang/helix/pkgs"};

    // preprocess the tokens with optional module import paths : stage 1
    print("preprocessing...", sysIO::endl('\r'));
    parser::preprocessor::Preprocessor(tokens, "main", pkg_paths).parse();

    // preprocessor::import_tree->print_tree(preprocessor::import_tree->get_root());

    // print the preprocessed tokens

    if parsed_args.emit_tokens {
        // print(tokens.to_json());
        print(tokens.to_json());
        print_tokens(tokens);
    }

    __TOKEN_N::TokenList new_tokens;  // remove all comments form `tokens`

    for &token in tokens {
        if token->token_kind() != __TOKEN_N::PUNCTUATION_SINGLE_LINE_COMMENT &&
            token->token_kind() != __TOKEN_N::PUNCTUATION_MULTI_LINE_COMMENT {
            new_tokens.push_back(token.current().get());
        }
    }

    tokens = new_tokens;  // FIXME: integrate this into the parser

    // generate ast from the given tokens : stage 2
    let iter = tokens.begin();

    print("parsing...         ", sysIO::endl('\r'));

    let ast: parser::ast::NodeV<>        ;
    let expr: parser::ast::ParseResult<> ;

    while (iter.remaining_n() != 0) {
        print("parsing.. ", sysIO::endl('\r'));
        let decl = parser::ast::node::Declaration(iter);
        expr     = decl.parse();

        print("parsing.  ", sysIO::endl('\r'));
        
        if !expr.has_value() {
            expr.error().panic();
            print(expr.error().what());

            break;
        }

        ast.emplace_back(expr.value());
        print("Parsing...", sysIO::endl('\r'));
    }

    if !expr.has_value():
        print("aborting...", sysIO::endl('\r'));
    else:
        print("parsed     ", sysIO::endl('\r'));

    if parsed_args.emit_ast {
        let node_json: std::vector<neo::json>;

        for &node in ast {
            let json_visitor: parser::ast::visitor::Jsonify;
            
            node->accept(json_visitor);
            node_json.push_back(json_visitor.json);
        }

        print(neo::json("ast").add("Decls", node_json).to_string());
    }

    let emitter: generator::CXIR::CXIR;

    for &node in ast {
        node->accept(emitter);
    }

    if (parsed_args.emit_ir) {
        print("emitting CX-IR...", sysIO::endl('\r'));

        if (parsed_args.verbose) {
            print(colors::fg16::green, emitter.to_CXIR(), colors::reset);
        } else {
            print(emitter.to_readable_CXIR());
        }
    }

    let out_file: std::string = (parsed_args.output_file.has_value())
                   ? parsed_args.output_file.value()
                   : std::filesystem::path(in_file_path).stem().string();

    let is_debug: bool = parsed_args.build_mode == __CONTROLLER_CLI_N::CLIArgs::MODE::DEBUG_;

    compile_CXIR(emitter, out_file, is_debug);

    let end = std::chrono::high_resolution_clock::now();

    let diff: std::chrono::duration<double> = end - start;

    if parsed_args.verbose {
        // Print the time taken in nanoseconds and milliseconds
        print("time taken: ", diff.count() * 1e+9, " ns");
        print("            ", diff.count() * 1000, " ms");
    }

    return 0;
}

fn main(int argc, char **argv) -> int {
    try:
        compile(argc, argv);
    
    catch (err: &error::Panic):
        if error::HAS_ERRORED:
            for err in error::ERRORS:
                print(err.to_json());
}

