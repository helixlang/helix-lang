//===----------------------------------------- Helix -----------------------------------------====//
//                                                                                                //
//  Part of the Helix Project, under the Attribution 4.0 International license (CC BY 4.0).       //
//  You are allowed to use, modify, redistribute, and create derivative works, even for           //
//  commercial purposes, provided that you give appropriate credit, and indicate if changes       //
//   were made. For more information, please visit: https://creativecommons.org/licenses/by/4.0/  //
//                                                                                                //
//  SPDX-License-Identifier: CC-BY-4.0                                                            //
//  Copyright (c) 2024 (CC BY 4.0)                                                                //
//                                                                                                //
//====----------------------------------------------------------------------------------------====//
//                                                                                                //
// this is the drop in replacement for the entire Helix compiler, this will be used when          //
// rewriting the compiler in helix itself (self-hosting), the reason this is the entry point is   //
// helix the compiler can now work with the c++ interop modules rather then having to compile     //
// only helix files into c++ headers then include them, instead we can now just use bi-directional//
// ffi to include c++ headers and use them in helix code.                                         //
//                                                                                                //
//====----------------------------------------------------------------------------------------====//


/*
using the new toolchain the entire process can happen like this:
*/

fn helix_compiler(std::array::<std::string, N> args) -> i32 requires <N: std::size_t> {
    let invoke:      InvocationManager       = InvocationManager(args, true);
    let compile:     CompilationUnit         = CompilationUnit(invoke);
    let diag_handle: PrettyDiagnosticHandler = PrettyDiagnosticHandler();

    // frontend processors
    compile.add_frontend_processor(LexicalProcessor());
    compile.add_frontend_processor(PreProcessor());
    compile.add_frontend_processor(ASTProcessor());

    // backend processors
    compile.add_backend_processor(CXIRGenerator());
    compile.add_backend_processor(ExecutableGenerator<OutputFormat::Executable>());

    // set diagnostics
    compile.set_diagnostic_handler(diag_handle);

    if (compile.execute() != InvocationManager::Success) {
        switch (compile.exit_state) {
            case InvocationManager::CompilerError:
                log(
                    "compiler internal error: ",
                    diag_handle
                        .get<InvocationManager::CompilerError>()
                        .format()
                        .to_string()
                ); break;

            case InvocationManager::CodeError:
                log(
                    "user code error: ",
                    diag_handle
                        .get<InvocationManager::CodeError>()
                        .format()
                        .to_string()
                ); break;

            case InvocationManager::UnrecoverableError:
                log(
                    "fatal error: ",
                    diag_handle
                        .get<InvocationManager::UnrecoverableError>()
                        .format()
                        .to_string()
                ); break;

            case InvocationManager::SystemError:
                log(
                    "sys call error: ",
                    diag_handle
                        .get<InvocationManager::SystemError>()
                        .format()
                        .to_string()
                ); break;
        };

        diag_handle.panic(PrettyDiagnosticHandler::ColorMode::ON);
    }

    return 0;
}

/* other.hlx
```helix

import main;

fn run_tests() {
    test main; // runs all tests defined in main.hlx
    test main["this is main.hlx"]; // runs the test with the given name
}

fn main() -> int {
    run_tests();

    // everything else

    return 0;
}

```
*/

