# This file was automatically generated by the Helix transpiler
# Date, Time: 2024-03-06 22:08:03
# Do not modify this file, as it will be overwritten
# License: CC0 1.0 Universal
# SPDX-License-Identifier: CC0-1.0
from __future__ import annotations
import os, sys
sys.path.append(os.path.dirname(os.path.realpath("c:\\Users\\dhruv\\Documents\\Projects\\helix\\helix.py")))
sys.path.append(os.path.dirname(os.path.realpath(os.getcwd())))
from include.core import *
from include.core import __import_c__
import threading
import functools
__lock = threading.Lock()
__file__ = "C:\\Users\\dhruv\\Documents\\Projects\\helix\\syntax\\test.hlx"
def exception_handler(exception_type: type[BaseException], exception: Exception = None, tb: types.TracebackType = None, debug_hook: bool = False, thread_error: bool = False):
    import traceback, linecache, inspect, os
    from include.core import __tokenize_line__
    print()
    thread_name = None
    if thread_error:
        thread_name = exception_type.thread.name
        exception = exception_type.exc_value
        tb = exception_type.exc_traceback
        exception_type = exception_type.exc_type
    stack = traceback.extract_tb(tb)
    current_exception = exception
    relevant_frames = []
    early_replacements = dict((v, k) for k, v in {'...': 'None', 'true': 'True', 'false': 'False', 'null': 'None', 'none': 'None', '&&': 'and', '||': 'or', '!': 'not', '===': 'is', '!==': 'is not', 'stop': 'break', '::': '.', 'new': '__init__', 'delete': '__del__', 'enter': '__enter__', 'exit': '__exit__', 'u8': 'hx_u8', 'u16': 'hx_u16', 'u32': 'hx_u32', 'u64': 'hx_u64', 'u128': 'hx_u128', 'i8': 'hx_i8', 'i16': 'hx_i16', 'i32': 'hx_i32', 'i64': 'hx_i64', 'i128': 'hx_i128', 'f32': 'hx_f32', 'f64': 'hx_f64', 'f128': 'hx_f128'}.items())
    # First loop: filter out irrelevant frames
    index = 0
    for frame in stack:
        filename = frame.filename
        line_no = frame.lineno
        if "source_py_" in os.path.basename(filename):
            filename = __file__
            line_no = int(open(frame.filename + ".lines", "r").readlines()[line_no])
            if line_no == -1:
                continue
        # Check specific conditions to skip
        if (
            linecache.getline(filename, line_no-1).strip() == "func = self.dispatch(*args)"
            and
            linecache.getline(filename, line_no).strip() == "return func(*args, **kwargs)"
        ):
            continue
        relevant_frames.append((index, frame))
        index += 1
    if len(relevant_frames) > 1:
        __lock.acquire(blocking=True, timeout=1.2)
        for frame_info in relevant_frames:
            index, frame = frame_info
            filename = frame.filename
            line_no = frame.lineno
            if "source_py_" in os.path.basename(filename):
                filename = __file__
                line_no = int(open(frame.filename + ".lines", "r").readlines()[line_no])
            # Attempt to find the marked part in the error message
            # see if the frame contains colno and end_colno
            marks = None
            if hasattr(frame, "colno") and hasattr(frame, "end_colno"):
                marks = list(__tokenize_line__(frame._line[frame.colno:frame.end_colno]))
            try:
                file_ext =  os.path.basename(filename).split('.')[1]
            except IndexError:
                file_ext = "py"
            if marks:
                panic(
                    current_exception,
                    *marks,
                    file=filename,
                    line_no=line_no,
                    multi_frame=True,
                    pos=0 if index == 0 else 1 if index < len(relevant_frames) - 1 else 2,
                    replacements=early_replacements,
                    follow_marked_order=True,
                    mark_start=frame.colno,
                    thread_name=thread_name,
                    lang=file_ext
                )
            else:
                panic(
                    current_exception,
                    file=filename,
                    line_no=line_no,
                    replacements=early_replacements,
                    multi_frame=True,
                    pos=0 if index == 0 else 1 if index < len(relevant_frames) - 1 else 2,
                    thread_name=thread_name,
                    lang=file_ext
                )
            current_exception = current_exception.__cause__ if current_exception.__cause__ else current_exception
        else:
            __lock.release()
            exit(1)
    else:
        __lock.acquire(blocking=True, timeout=0.1)
        index, frame = relevant_frames[0]
        filename = frame.filename
        line_no = frame.lineno
        if "source_py_" in filename:
            filename = sys.argv[0]
            line_no = int(open(frame.filename + ".lines", "r").readlines()[line_no])
        # Attempt to find the marked part in the error message
        # see if the frame contains colno and end_colno
        marks = None
        if hasattr(frame, "colno") and hasattr(frame, "end_colno"):
            marks = list(__tokenize_line__(frame._line[frame.colno:frame.end_colno]))
        try:
            file_ext =  os.path.basename(filename).split('.')[1]
        except IndexError:
            file_ext = "py"
        if marks:
            panic(
                current_exception,
                *marks,
                file=filename,
                line_no=line_no,
                replacements=early_replacements,
                no_exit=True,
                follow_marked_order=True,
                mark_start=frame.colno,
                thread_name=thread_name,
                lang=file_ext
            )
        else:
            panic(
                current_exception,
                file=filename,
                line_no=line_no,
                replacements=early_replacements,
                no_exit=True,
                thread_name=thread_name,
                lang=file_ext
            )
        __lock.release()
        exit(1)
sys.excepthook = exception_handler
threading.excepthook = functools.partial(exception_handler, thread_error=True)
def __internal_replace_argv(args: list[str]) -> list[str]:
    sys.argv = ["syntax/test.hlx"] + list(args)[2:]
    return sys.argv
import types
import functools
import os
import random
class C_cout():
    def __init__(self: Any, __val: 'C_cout'):
            raise NotImplementedError("Define an __init__ method for this class with the function signature new(self: Any, inst_class: 'C_cout')")
    def __init__(self: Any):
        None
    def __lshift__(self: Any, a: str | hx_string):
        1 / 0
@hx__multi_method
def main():
    cout: C_cout = (C_cout ( ))
    cout << "Hello  World"
@hx__multi_method
def subtract(a: int | hx_int, b: int | hx_int) -> int:
    return a / 0
@hx__multi_method
def add(a: int | hx_int, b: int | hx_int) -> int:
    return a + b
if __name__ == "__main__":
    try:
        try:
            main(hx_list(__internal_replace_argv(sys.argv)).__set_generic__("[str]"))
        except TypeError:
            try:
                main()
            except KeyboardInterrupt as e2:
                panic(
                    e2.__cause__,
                    ":",
                    file=inspect.stack()[0].filename,
                    line_no=e2.__traceback__.tb_lineno,
                )
    except KeyboardInterrupt as e2:
        panic(
            e2.__cause__,
            ":",
            file=inspect.stack()[0].filename,
            line_no=e2.__traceback__.tb_lineno,
        )
