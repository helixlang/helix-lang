# This file was automatically generated by the Helix transpiler
# Do not modify this file, as it will be overwritten
# License: CC0 1.0 Universal
# SPDX-License-Identifier: CC0-1.0
from __future__ import annotations
import os, sys
sys.path.append(os.path.dirname(os.path.realpath("c:\\Users\\dhruv\\Documents\\Projects\\helix\\helix.py")))
sys.path.append(os.path.dirname(os.path.realpath(os.getcwd())))
from include.core import *
from include.core import __import_c__
def exception_handler(exception_type: type[BaseException], exception: Exception, tb: types.TracebackType, debug_hook: bool = False):
    import traceback, linecache, inspect
    stack = traceback.extract_tb(tb)
    current_exception = exception
    relevant_frames = []
    early_replacements = dict((v, k) for k, v in {'...': 'None', 'true': 'True', 'false': 'False', 'null': 'None', 'none': 'None', '&&': 'and', '||': 'or', '!': 'not', '===': 'is', '!==': 'is not', 'stop': 'break', '::': '.', 'new': '__init__', 'delete': '__del__', 'enter': '__enter__', 'exit': '__exit__', 'u8': 'hx_u8', 'u16': 'hx_u16', 'u32': 'hx_u32', 'u64': 'hx_u64', 'u128': 'hx_u128', 'i8': 'hx_i8', 'i16': 'hx_i16', 'i32': 'hx_i32', 'i64': 'hx_i64', 'i128': 'hx_i128', 'f32': 'hx_f32', 'f64': 'hx_f64', 'f128': 'hx_f128'}.items())
    # First loop: filter out irrelevant frames
    for index, frame in enumerate(reversed(stack)):
        filename = frame.filename
        line_no = frame.lineno
        if "source_py_" in filename:
            filename = sys.argv[0]
            line_no = int(open(frame.filename + ".lines", "r").readlines()[line_no])
            print(f"{filename}:{line_no}")
            if line_no == -1:
                continue
        # Check specific conditions to skip
        if (
            linecache.getline(filename, line_no-1).strip() == "func = self.dispatch(*args)"
            and
            linecache.getline(filename, line_no).strip() == "return func(*args, **kwargs)"
        ):
            continue
        relevant_frames.append((index, frame))
    # Second loop: process each relevant frame
    if len(relevant_frames) > 1:
        for frame_info in relevant_frames:
            index, frame = frame_info
            filename = frame.filename
            line_no = frame.lineno
            if "source_py_" in filename:
                filename = sys.argv[0]
                line_no = int(open(frame.filename + ".lines", "r").readlines()[line_no])
            # repalce early replacements within the current_exception message
            current_exception.__str__ = lambda: current_exception.__str__().format(**early_replacements)
            panic(
                current_exception,
                file=filename,
                line_no=line_no,
                multi_frame=True,
                pos=0 if index == 0 else 1 if index < len(stack) - 1 else 2,
                replacements=early_replacements
            )
            current_exception = current_exception.__cause__ if current_exception.__cause__ else current_exception
        else:
            exit(1)
    else:
        index, frame = relevant_frames[0]
        filename = frame.filename
        line_no = frame.lineno
        if "source_py_" in filename:
            filename = sys.argv[0]
            line_no = int(open(frame.filename + ".lines", "r").readlines()[line_no])
        panic(
            current_exception,
            file=filename,
            line_no=line_no,
            replacements=early_replacements
        )
sys.excepthook = exception_handler
def __internal_replace_argv(args: list[str]) -> list[str]:
    sys.argv = ["syntax/test.hlx"] + list(args)[2:]
    return sys.argv
import types
import functools
import os
import random
class Field():
    def __init__(self: Any, __val: 'Field'):
            raise NotImplementedError("Define an __init__ method for this class with the function signature new(self: Any, inst_class: 'Field')")
    def __init__(self: Any, w: int | hx_int, h: int | hx_int):
        self . w  = w
        self . h  = h
        self . s = std . generate ( h , lambda y : std . generate ( w , lambda x : False ) )
    def set(self: Any, x: int | hx_int, y: int | hx_int, b: bool | hx_bool):
        self . s [ y ] [ x ]  = b
    def alive(self: Any, x: int | hx_int, y: int | hx_int) -> bool:
        try:
            x  = ( x + self . w ) % self . w
        except AttributeError:
            x  = ( x + self . w ) % self . w
            print("WARN: \"x \" does not contain the attribute '__set__' falling back to default assignment.")
        try:
            y  = ( y + self . h ) % self . h
        except AttributeError:
            y  = ( y + self . h ) % self . h
            print("WARN: \"y \" does not contain the attribute '__set__' falling back to default assignment.")
        return self . s [ y ] [ x ]
    def next(self: Any, x: int | hx_int, y: int | hx_int) -> bool:
        alive: int | hx_int = int(0)
        for i in C_For(i = int(- 1)).set_con('i <= 1').set_inc('i ++'):
            for j in C_For(j = int(- 1)).set_con('j <= 1').set_inc('j ++'):
                if (( ( i != 0 or j != 0 ) and self . alive ( x + i , y + j ) )):
                    alive += 1
            del j
        del i
        return alive == 3 or ( alive == 2 and self . alive ( x , y ) )
class Life():
    def __init__(self: Any, __val: 'Life'):
            raise NotImplementedError("Define an __init__ method for this class with the function signature new(self: Any, inst_class: 'Life')")
    def __init__(self: Any, w: int | hx_int, h: int | hx_int):
        self . w  = w
        self . h  = h
        self . a  = Field . __init__ ( w , h )
        self . b  = Field . __init__ ( w , h )
        for _ in C_For(_ = int(0)).set_con('_ < w * h / 4').set_inc('_ ++'):
            self . a . set ( random . randint ( 0 , w - 1 ) , random . randint ( 0 , h - 1 ) , True )
        del _
    def step(self: Any):
        for y in C_For(y = int(0)).set_con('y < self . h').set_inc('y ++'):
            for x in C_For(x = int(0)).set_con('x < self . w').set_inc('x ++'):
                self . b . set ( x , y , self . a . next ( x , y ) )
            del x
        del y
        self . a  = self . b
        self . b  = self . a
    def __str__(self: Any) -> string:
        result: str | hx_string = str("")
        for y in C_For(y = int(0)).set_con('y < self . h').set_inc('y ++'):
            for x in C_For(x = int(0)).set_con('x < self . w').set_inc('x ++'):
                if (( self . a . alive ( x , y ) )):
                    result += '*'
                else:
                    result += ' '
            del x
            result += '\n'
        del y
        return result
@hx__multi_method
def main():
    l: Life = (Life . __init__ ( 40 , 15 ))
    for _ in C_For(_ = int(0)).set_con('_ < 300').set_inc('_ ++'):
        l . step ( )
        if (( os . name == 'nt' )):
            os . system ( 'cls' )
        else:
            os . system ( 'clear' )
        printf ( l )
        sleep ( 1 / 30 )
    del _
if __name__ == "__main__":
    try:
        try:
            main(hx_list(__internal_replace_argv(sys.argv)).__set_generic__("[str]"))
        except TypeError:
            try:
                main()
            except KeyboardInterrupt as e2:
                panic(
                    e2.__cause__,
                    ":",
                    file=inspect.stack()[0].filename,
                    line_no=e2.__traceback__.tb_lineno,
                )
    except KeyboardInterrupt as e2:
        panic(
            e2.__cause__,
            ":",
            file=inspect.stack()[0].filename,
            line_no=e2.__traceback__.tb_lineno,
        )
