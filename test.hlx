
macro tokens!(create) {
    create!(LET, "let");
    create!(FN, "fn");
    create!(CLASS, "class");
    create!(STATIC, "static");
    create!(RETURN, "return");
    create!(PRINT, "print");
    create!(FMT, "f");
    create!(STRING, "string");
    create!(INT, "i32");
    create!(L_PAREN, "(");
    create!(R_PAREN, ")");
    create!(L_BRACE, "{");
    create!(R_BRACE, "}");
    create!(L_BRACKET, "[");
    create!(R_BRACKET, "]");
    create!(COMMA, ",");
    create!(SEMICOLON, ";");
    create!(COLON, ":");
    create!(ARROW, "->");
    create!(EQ, "=");
    create!(PLUS, "+");
    create!(MINUS, "-");
    create!(STAR, "*");
    create!(SLASH, "/");
    create!(BANG, "!");
};

macro generate_case!(kind, value) {
    case TokenKind::kind:
        return value;
    ;
};
 
macro generate_enum!(kind, value) {
    kind,
};

enum TokenKind {
    tokens!(generate_enum)
}


fn string_of_token(kind: TokenKind) -> string {
    
}


// -------------------------------------------------------- //


class Span {
    let start: usize;
    let end:   usize;

    fn length() -> usize {
        return self.end - self.start;
    }
}

struct Location {
    let line:   usize;
    let column: usize;
    let span:   Span;
    let file:  &string;
}

class Token {
    pub let kind: TokenKind;
    pub let value: string;
    pub let location: Location;
    pub let span: Span;

    op as fn (self) -> string {
        switch kind {
            tokens!(generate_case)
        }

        return "unknown";
    }
}
