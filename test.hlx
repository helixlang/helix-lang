class Node {
    pub let value: i32;
    pub let next: *Node = &null;

    // constructor for Node
    fn Node(self, value: i32) {
        self.value = value;
    }
}

fn printReverseList(head: *Node) {
    if head->next != &null:
        printReverseList(head->next);

    print(f"{head->value} ");
}

fn pow(base: u64, exp: u64) -> u64 {
    let result = 1;
    let e = exp;

    while e > 0 {
        if e % 2 == 1 {
            result *= base;
        }
        base *= base;
        e /= 2;
    }

    return result;
}

fn str_to_u64(s: &string) -> u64 {
    let result: u64 = 0;
    let i = 0;

    while i < s.size() {
        let digit = (s[i] as u64) - ('0' as u64);
        result = result * 10 + digit;
        i += 1;
    }

    return result;
}

fn num_concat(number: &string) -> u64 {
    let final_num: u64 = 0;
    let n: list::<string>;

    let len = number.length();
    let i = 0;

    while i < len {
        let end = (i + 32) if (i + 32 < len) else len;
        n.push_back(number.substr(i, end));
        i += 32;
    }

    let iter = 0;

    if n.size() > 1 && n[0][0] == '-' {
        n[0] = n[0].substr(1);
    }

    while iter < n.size() {
        let val = str_to_u64(n[iter]);
        
        if iter == n.size() - 1:
            final_num = final_num * pow(10, ((n[iter].length()) as u64)) + val;
        else:
            final_num = final_num * pow(10, 32) + val;

        iter += 1;
    }

    return final_num;
}

class AClass
  requires <T: class, ...Es> {
    ...
}

extend AClass::<T, Es...> with SomeInterface
  requires <T: class, ...Es> if (traits::is_class_v::<Es> && ...) {
    ...
}

extend AClass::<T, Es...> // without extending an interface
  requires <T: class, ...Es> if (traits::is_class_v::<T> && (traits::is_class_v::<Es> && ...)) {
    ...
}

// ------------------ simple example of requires specialization ------------------
class SomeOtherClass requires <T> {
    ...
}

extend SomeOtherClass::<T> with SomeInterface
  requires <T> {
    ...
}

extend SomeOtherClass::<i32> { // without extending an interface and a specific type
    ...
}

// ------------------ even simpler example of requires specialization ------------------
class AnotherClass {
    ...
}

extend AnotherClass { // this directly adds everything defined in the extension into the class itself
    ...
}


interface JsonIfy {
    fn to_json(self) -> string {};
}

class Book {
    let val: i32;

    fn Book(self, val: i32) {
        self.val = val;
    }

    op as fn (self) -> string {
        return "class: Book";
    }
}

extend Book with JsonIfy {
    fn to_json(self) -> &self {
        return f"val: {*&self.val}";
    }
}



// entry point
fn main() -> i32 {
    let num = "123849771248217498127421874128412941";
    let result = num_concat(num);
    print(f"Result: {result}");
}
