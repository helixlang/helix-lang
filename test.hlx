fn test() -> std::Questionable::<i32> {
    panic std::errors::RuntimeError("this is a panic");
}

fn see_if_this_works() {
    let x: std::Questionable::<i32> = test();

    try {
        x as i32;
    } catch std::errors::RuntimeError {
        print("woah a runtime error how?");
    } catch {
        print("some other error");
    }

    // if (x == null) {
    //     print("null");
    // } else if (x == std::errors::RuntimeError()) {
    //     print("error: some error here");
    // } else {
    //     print(x as i32);
    // }
}

fn main() -> i32 {
    see_if_this_works();
    return 0;
}

/*
ffi "c++" import "exception";

fn pow(base: u64, exp: u64) -> u64 {
    let result: u64 = 1;
    let e = exp;

    while e > 0 {
        if e % 2 == 1 {
            if result > 0xFFFFFFFFFFFFFFFF / base {
                print("overflow");
                panic libcxx::runtime_error("overflow detected during pow computation");
            }
            result *= base;
        }
        
        if base > 0xFFFFFFFFFFFFFFFF / base {
            print("overflow");
            panic libcxx::runtime_error("overflow detected during pow computation");
        }
        
        base *= base;
        e /= 2;
    }

    return result;
}

fn to_u64(s: &string) -> u64 {
    let result: u64 = 0;
    let i = 0;

    while i < s.size() {
        let digit = (s[i] as u64) - ('0' as u64);
        
        if result > (0xFFFFFFFFFFFFFFFF - digit) / 10 {
            print("overflow");
            panic libcxx::runtime_error("overflow detected during to_u64 computation");
        }
        
        result = result * 10 + digit;
        i += 1;
    }

    return result;
}

fn main() -> i32 {
    let num = "12384979813122731242141";
    let result = to_u64(num);
    print(f"Result: {result}");
}

// fn to_large(number: &string) -> u64 {
//     let final_num: u64 = 0;
//     let n: list::<string>;

//     let len = number.length();
//     let i = 0;

//     while i < len {
//         let end = (i + 32) if (i + 32 < len) else len;
//         n.push_back(number.substr(i, end));
//         i += 32;
//     }

//     let iter = 0;

//     if n.size() > 1 && n[0][0] == '-' {
//         n[0] = n[0].substr(1);
//     }

//     while iter < n.size() {
//         let val = str_to_u64(n[iter]);
        
//         if iter == n.size() - 1:
//             final_num = final_num * pow(10, ((n[iter].length()) as u64)) + val;
//         else:
//             final_num = final_num * pow(10, 32) + val;

//         iter += 1;
//     }

//     return final_num;
// }


// class AClass
//   requires <T: class, ...Es> {
//     ...
// }

// extend AClass::<T, Es...> with SomeInterface
//   requires <T: class, ...Es> if (traits::is_class_v::<Es> && ...) {
//     ...
// }

// extend AClass::<T, Es...> // without extending an interface
//   requires <T: class, ...Es> if (traits::is_class_v::<T> && (traits::is_class_v::<Es> && ...)) {
//     ...
// }

// // ------------------ simple example of requires specialization ------------------
// class SomeOtherClass requires <T> {
//     ...
// }

// extend SomeOtherClass::<T> with SomeInterface
//   requires <T> {
//     ...
// }

// extend SomeOtherClass::<i32> { // without extending an interface and a specific type
//     ...
// }

// // ------------------ even simpler example of requires specialization ------------------
// class AnotherClass {
//     ...
// }

// extend AnotherClass { // this directly adds everything defined in the extension into the class itself
//     ...
// }


// interface JsonIfy {
//     fn to_json(self) -> string {};
// }

// class Book {
//     let val: i32;

//     fn Book(self, val: i32) {
//         self.val = val;
//     }

//     op as fn (self) -> string {
//         return "class: Book";
//     }
// }

// extend Book with JsonIfy {
//     fn to_json(self) -> &self {
//         return f"val: {*&self.val}";
//     }
// }



// entry point

*/