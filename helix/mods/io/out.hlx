/// std::io::out - this is the internal code for print

ffi "c++" priv import <iostream> as cpp__io;

interface Stringable {
    fn to_string() -> string;
}

fn print(...args: T | U, sep: T = " ", end: T = "\n", flush: bool = false)
  requires <T, U> if T is Stringable {
    let out: string = "";

    for arg in args {
        if arg is T {
            out += arg.to_string();
        } else {
            out += f"<Non-Stringable at {*arg as hex}>";
        }
    }

    out = out.strip(*sep) + *end;

    ffi "C++" {
        cpp__io::std::cout << out;

        if flush {
            cpp__io::std::cout.flush();
        }
    }
}

import std::algorithm;
import std::io;
import std::file;
import std::range;

const cols: int = 14;

fn parse_char(c: char) -> string {
    return f"{c:02X}"
}

fn main() {
    let path: string = std::file_sytem::get_bin_path();
    let file = open(path, "rb");

    for chunk in file.read(cols) {
        chunk = chunk[0:20];

        let hex_chunk: string;
        for character in chunk {
            if (character as char) < 0x20 || (character as char) > 0x7E {
                hex_chunk += ".";
            } else {
                hex_chunk += character;
            }
        }

        let hex_str: string = std::map(chunk, parse_char).join(" ");
        let padding: string = " ".repeat(3 * (cols - chunk.len()));

        file.write(f"{hex_str}{padding}  {hex_chunk}\n");
    }

    file.close();
}

| **Control Flow** | **Function and Method** | **Class and Struct** |
|------------------|-------------------------|----------------------|
| break            | async                   | class                |
| case             | define                  | enum                 |
| continue         | fn                      | struct               |
| default          | inline                  | type                 |
| else             | macro                   | union                |
| for              | op                      |                      |
| if               | return                  |                      |
| match            | yield                   |                      |
| switch           |                         |                      |
| unless           |                         |                      |
| while            |                         |                      |

| **Inheritance and Polymorphism** | **Error Handling** | **Variable Declaration** |
|----------------------------------|--------------------|--------------------------|
| abstract                         | catch              | const                    |
| derives                          | finally            | let                      |
| interface                        | panic              | shared                   |
| requires                         | try                |                          |
|                                  | test               |                          |

| **Access Specifiers** | **Module Importing** | **Concurrency** | **Other** |
|-----------------------|----------------------|-----------------|-----------|
| module                | as                   | atomic          | delete    |
| priv                  | ffi                  | await           | is        |
| pub                   | import               | spawn           | null      |
| prot                  |                      | thread          | nullptr   |

/* ---------------------------------- usage --------------------------------- */

/*
    Deriving from `Stringable` is optional as long as `Foo` implements all
    methods of the interface. This allows `Foo` to satisfy generic constraints:

    - `Foo` will pass a generic constraint like `T: Stringable`.
    - However, `Foo` will fail a direct type check for the interface, e.g.,
        `if foo is Stringable`. If `Foo` does not explicitly derive `Stringable`,
        it will fail this check.
    - Conversely, `Foo` will pass type-based checks such as:
        `type StringableType requires <T> if Stringable;`
        `let foo: StringableType<Foo> = Foo{};`

    In this case, `Foo` would be valid because it contains all the methods of
    `Stringable` without necessarily deriving from it.
*/
struct Foo : Stringable {
    fn to_string() -> string {
        return "Foo";
    }
}

type StringableType requires <T> if Stringable;
type StringableType<T: Stringable>;

class Bar {}

fn main() {
    print("Hello, ", Foo(), "World!"); // Hello, Foo World!
    print("Hello, ", Bar(), "World!"); // Hello, <Non-Stringable at 0x...> World!
}
