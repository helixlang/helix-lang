
~*~
~~ op ^ as xor(lhs: bool, rhs: bool) -> bool {
~~     return lhs ^ rhs;
~~ }
static async fn factorial(n: int) -> int {
    if (n > 1) {
        return n * factorial(n - 1);
    } else {
        a: map<map<int, map<int, int>>, int>? = {
            {1 : {2 : 3} } : 3
        }; ~~ become a = map({{1 : {2 : 3} } : 3}, null_safe=False)

        return 1;
    }

    fn new_function(n: int) -> int {
        if (n == 0) {
            return 1;
        } else {
            return n * new_function(n - 1);
        }
    }

    for (var i = 0; t >= 0; i < 10; i++) {
        print(i);
    }

    return 0xff01;
}

fn main() {
    let n: int?; ~~ ? initializes to null instead of 0

    fn something(n: int) -> string {
        return match (n) {
            1 -> "one",
            2 -> "two",
            3 -> "three",
            _ -> "fuck all"
        };
    }

    n = int::parse(input("Enter a positive integer "));
    print("Factorial of " + n + " = " + factorial(n));

    return 0;
}

class Mammal {
    fn new(self: ref, name: string, age: int, breed: string) {}
    fn info() {}
}

class Dog::Mammal {
    let name:  string;
    let breed: string;
    let age:   int;

    override Mammal:
        async fn new(self: ref, name: string, age: int, breed: string) {
            self.breed = breed;
            self.name  = name;
            self.age   = age;

            let a: int = 1 add 2 sub 2;

            return a;

        }

        fn info() {
            print(self.name + " is a " + self.age + " year old " + self.breed);
        }
}

~* ------------------------------ EXAMPLES ---------------------------------- *~

~~ Import python and C++
include PY("numpy");
include "binary_sort" from CPP("sorting.cpp");


~~ Define a function
fn greet(name: string) {
    print(f"Hello, {name}!");
}

~~ Define a class
class Dog {
    fn new(self: ref, name: string, age: AgeType) {
        self.name = name;
        self.age  = age;
    }
}

~~ Create an instance of the class
fn main() {
    ~~ Create a new instance of the Dog class
    let dog: Dog = Dog("Buddy", 5);
    greet("World");

    ~~ Sort a list using C++
    let sorted: list = binary_sort([1, 2, 3, 4, 5]);

    ~~ Print outputs
    print("Squared numbers:", SQUARED_NUMBERS);
    print(f"{dog.name} is {dog.age} years old.");
}


~~ ------------------------------ EXAMPLES ---------------------------------- ~~
~~ Evaluated during compile time



fn main() {
    ~~ Create a new instance of the Dog class
    let arr: list = [12, 11, 13, 5, 6];

    ~~ Print outputs
    arr = insertion_sort(arr);
    print("Sorted array:", arr);
}

~~ Define a function
fn binary_search(arr: list, val: int, start: int, end: int) -> int {
    if start == end {
        if arr[start] > val {
            return start;
        } else {
            return start + 1;
        }
    }

    if (start > end) {
        return start;
    }

    let mid: EitherIntOrFloat = (start + end) / 2;

    if arr[mid] < val {
        return binary_search(arr, val, mid + 1, end);
    } unless arr[mid] > val {
        return binary_search(arr, val, start, mid - 1);
    } else {
        return mid;
    }
}
~*~
~~ var a, b : int = 0;                  FAIL + #TODO: single declaration for multiple variables not defined
~~ let a: float, var b: int = 0.2, 1;   FAIL + #TODO: unpacking not defined
include PY("numpy");
include "test" from RS("test.rs");
include ("add","sub") from CPP("test.cpp");

enum dog {
    let name:  string<int, string> = "Buddy";
    let breed, age: int = 21, 5;

    fn info() {
        print(f"a dog named {self.name} is a {self.age} year old {self.breed}");
        printf("a dog named %s is a %d year old %s", self.name, self.age, self.breed);
    }

    async fn new(self: ref, name: string<somehting, sad>, age: int, breed: string) {
        self.breed = breed;
        self.name  = name;
        self.age   = age;

        let a: int = 1 + 2 - 2;

        return a;

    }

}

or and is as use elif switch union enum unsafe 

in
auto
using
from

if
elif
else
unless

continue
while
for

case
default
switch
match

fn
lambda
thread
macro
async
return

class
interface
struct
union
enum
abstract

try
catch
finally
throw

break
delegate

private
protected
public
final
static
unsafe

let
const
var

include
import
using
from

yield from
yield
await

deadly fn get_data_from_mem_address(adress: int, size: int) -> array<ctypes::c_char> {
    let data: ctypes::c_ptr<ctypes::c_char> = ctypes::c_ptr(adress);
    return data[0:size];
}

deadly fn write_to_mem_address(adress: int, data: string) -> void {
    let data: BinaryData = data.encode("utf-8");
    let size: int = len(data);
    let buffer: ctypes::c_ptr<ctypes::c_char> = ctypes::c_ptr(data);

    try {
        ctypes::memcpy(adress, buffer, size);
        ctypes::free(buffer);
    } catch (e: AccessViolation) {
        let *ptr: auto = ctypes::malloc(size);
        sys::free(ptr, data, size);
        ctypes::memcpy(adress, ptr, size);
        ctypes::free(ptr);
    }

    print("wrote to memory");
}

fn read_pointer(a: Address) -> list<Binary> {
    let val: array<ctypes::c_char> = get_data_from_mem_address(a, 1000);
    let stream: list<Binary> = [_.get(val[i:i+4]) for _, i in zip(val, range(0, len(val), 4))];

    return stream;
}

fn main() {
    let g: Address = 0x7ff000000000;
    let data: list<Binary> = read_pointer(g);

    print(data);
}

fn some_fucntion(arr: list<string>) -> list {
        let arr: list<int> = [1, 2, 3];
        for var s, var i in arr {
            print(i);
        }

        for let i: int = 0; i < 10; i++ {
            print(i);
        }

        return arr;
    }


~~ i ++ , j += fomenc ( [ 1 , 2 , 3 ] )

~~ +: __add__
~~ &: __and__
~~ ==: __eq__
~~ //: __floordiv__
~~ >=: __ge__
~~ >: __gt__
~~ ~: __invert__
~~ <=: __le__
~~ <<: __lshift__
~~ <: __lt__
~~ %: __mod__
~~ *: __mul__
~~ !=: __ne__
~~ -: __neg__
~~ |: __or__
~~ +: __pos__
~~ **: __pow__
~~ +: __radd__
~~ &: __rand__
~~ //: __rfloordiv__
~~ <<: __rlshift__
~~ %: __rmod__
~~ *: __rmul__
~~ |: __ror__
~~ **: __rpow__
~~ >>: __rrshift__
~~ >>: __rshift__
~~ -: __rsub__
~~ /: __rtruediv__
~~ ^: __rxor__
~~ -: __sub__
~~ /: __truediv__
~~ ^: __xor__
~~
~~ to_bool: __bool__
~~ to_string: __str__
~~ to_float: __float__
~~ to_hash: __hash__
~~ to_int: __int__
~~
~~ math.ceil: __ceil__
~~ __class__
~~ divmod: __divmod__
~~ docstring: __doc__
~~ abs: __abs__
~~ math.floor: __floor__
~~ str.format: __format__
~~ attribute access: __getattribute__
~~ index: __index__
~~ new: __init__
~~ __init_subclass__: __init_subclass__
~~ object creation: __new__
~~ divmod: __rdivmod__
~~
~~ reduce protocol for pickling: __reduce__
~~ extended reduce for pickling: __reduce_ex__
~~
~~ new arguments for serialization: __getnewargs__
~~ repr: __repr__
~~ round: __round__
~~ set attribute: __setattr__
~~ sys.getsizeof: __sizeof__
~~ __subclasshook__
~~ math.trunc: __trunc__
~~ All Primitive Types
~~ int;
~~ string;
~~ float;
~~ map;
~~ list;
~~ bool;
~~ char;
~~ void;
~~ tuple;
~~ array;
~~ set;

~~ u8;
~~ u16;
~~ u32;
~~ u64;
~~ u128;
~~ i8;
~~ i16;
~~ i32;
~~ i64;
~~ i128;
~~ f32;
~~ f64;
~~ f128;