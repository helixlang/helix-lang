fn divide(parm1: &int, const parm2: &i32) -> Exception? {
    // some implementation
}

type SomeUnion = int | float | string;



fn main() {
    let x = 5;
    let y = &x;

    *y += 1;

    print("{}", x);

    let const new_re = (1, 2, 3)    ;
    let const new_re = [1, 2, 3]    ;
    let const new_re = {1, 2, 3}    ;
    let const new_re = {"yes" : 123};

    // const vars can be reassigned

    if result is DivideByZero {
        print("Divide by zero error");
    } else {
        print(f"Result is: {result}");
    }
}

/*

in the case devide's signature is `fn divide(parm1: &int, const parm2: i32) -> Exception?`
since the fucntion parm is a refrence, the caller MUST pass a refrence to the function
so the call should be `divide(&x, y);` instead of `divide(x, y);`

doing `divide(x, y);` would result in this error:
error: expected a reference to an 'int' but got a copy instead
    -->  at tests/main.hlx:1:4
   1 | let result? = divide(x, y);
     :               ~~~~~~~^~~~~
     |
  fix: change the call to `divide(&x, y);`

    note: the function definition is:
       -->  at tests/main.hlx:4:4
      4 | fn divide(parm1: &int, const parm2: i32) -> Exception? {
      5 |     if parm2 == 0 {
      6 |         return DivideByZero;

error: aborting due to previous error
```

*/