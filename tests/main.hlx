ffi "c++" import "cstdio";
ffi "c++" import "iostream";
ffi "c++" import "vector";
ffi "c++" import "string";
ffi "c++" import "concepts"; 
// TODO: Make this is only to be added if interfaces are used that return types

// Define the Fraction struct with n and d (numerator and denominator)
struct Fraction {
    let n: int;
    let d: int;
}

// Add function at the global scope
fn add(a: int, b: int) -> int {
    return a + b;
}

// Overload the addition operator for Fraction
op + fn add(a: Fraction, b: Fraction) -> Fraction {
    let new_n = add(a.n + b.d, b.n + a.d);
    let new_d = a.d * b.d;
    return Fraction { n= new_n, d = new_d };
}

op - fn subtract(a: Fraction, b: Fraction) -> Fraction {
    let new_n = add(a.n - b.d, b.n - a.d);
    let new_d = a.d * b.d;
    return Fraction { n= new_n, d= new_d };
}

op * fn multiply(a: Fraction, b: Fraction) -> Fraction {
    let new_n = a.n * b.n;
    let new_d = a.d * b.d;
    return Fraction { n= new_n, d= new_d };
}

op / fn divide(a: Fraction, b: Fraction) -> Fraction {
    let new_n = a.n * b.d;
    let new_d = a.d * b.n;
    return Fraction { n= new_n, d= new_d };
}
/* 
*/

// + - * / % ^ & | ~ ! = < > += -= *= /= %= ^= &= |= << >> >>= <<= == != <= >= <=>(since C++20) && || ++ -- , ->* -> ( ) [ ]

// Overload the unary minus operator for Fraction
op - fn unary_minus(a: Fraction) -> Fraction {
    return Fraction { n= -a.n, d= a.d };
}

// Overload the unary plus operator for Fraction

op + fn unary_plus(a: Fraction) -> Fraction {
    return Fraction { n= a.n, d= a.d };
}

// Overload the increment operator for Fraction

op ++ fn increment(a: Fraction) -> Fraction {
    return Fraction { n= a.n + a.d, d= a.d };
}

// Overload the decrement operator for Fraction

op -- fn decrement(a: Fraction) -> Fraction {
    return Fraction { n= a.n - a.d, d= a.d };
}

// Overload the addition assignment operator for Fraction

op += fn add_assign(a: Fraction, b: Fraction) -> Fraction {
    return a + b;
}

// Overload the subtraction assignment operator for Fraction

op -= fn subtract_assign(a: Fraction, b: Fraction) -> Fraction {
    return a - b;
}

// Overload the multiplication assignment operator for Fraction

op *= fn multiply_assign(a: Fraction, b: Fraction) -> Fraction {
    return a * b;
}

// Overload the division assignment operator for Fraction

op /= fn divide_assign(a: Fraction, b: Fraction) -> Fraction {
    return a / b;
}

// Overload the modulus assignment operator for Fraction

op %= fn modulus_assign(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n % b.n, d= a.d % b.d };
}

// Overload the bitwise AND assignment operator for Fraction

op &= fn bitwise_and_assign(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n & b.n, d= a.d & b.d };
}

// Overload the bitwise OR assignment operator for Fraction

op |= fn bitwise_or_assign(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n | b.n, d= a.d | b.d };
}

// Overload the bitwise XOR assignment operator for Fraction

op ^= fn bitwise_xor_assign(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n ^ b.n, d= a.d ^ b.d };
}

// Overload the left shift assignment operator for Fraction

op <<= fn left_shift_assign(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n << b.n, d= a.d << b.d };
}

// Overload the right shift assignment operator for Fraction

op >>= fn right_shift_assign(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n >> b.n, d= a.d >> b.d };
}

// Overload the modulus operator for Fraction

op % fn modulus(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n % b.n, d= a.d % b.d };
}

// Overload the bitwise AND operator for Fraction

op & fn bitwise_and(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n & b.n, d= a.d & b.d };
}

// Overload the bitwise OR operator for Fraction

op | fn bitwise_or(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n | b.n, d= a.d | b.d };
}

// Overload the bitwise XOR operator for Fraction   

op ^ fn bitwise_xor(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n ^ b.n, d= a.d ^ b.d };
}

// Overload the left shift operator for Fraction

op << fn left_shift(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n << b.n, d= a.d << b.d };
}

// Overload the right shift operator for Fraction

op >> fn right_shift(a: Fraction, b: Fraction) -> Fraction {
    return Fraction { n= a.n >> b.n, d= a.d >> b.d };
}

// Overload the comparison operators for Fraction

op < fn less_than(a: Fraction, b: Fraction) -> bool {
    return a.n * b.d < b.n * a.d;
}

op > fn greater_than(a: Fraction, b: Fraction) -> bool {
    return a.n * b.d > b.n * a.d;
}

op <= fn less_than_or_equal(a: Fraction, b: Fraction) -> bool {
    return a.n * b.d <= b.n * a.d;
}

op >= fn greater_than_or_equal(a: Fraction, b: Fraction) -> bool {
    return a.n * b.d >= b.n * a.d;
}

// op <=> fn three_way_comparison(a: Fraction, b: Fraction) -> int {
//     if a.n * b.d < b.n * a.d {
//         return -1;
//     } else if a.n * b.d > b.n * a.d {
//         return 1;
//     } else {
//         return 0;
//     }
// }

op && fn logical_and(a: Fraction, b: Fraction) -> bool {
    return a.n && b.n && a.d && b.d;
}

op || fn logical_or(a: Fraction, b: Fraction) -> bool {
    return a.n || b.n || a.d || b.d;
}

op ! fn logical_not(a: Fraction) -> bool {
    return !a.n && !a.d;
}

// Overload the equality operator for Fraction
op == fn equals(a: Fraction, b: Fraction) -> bool {
    return a.n * b.d == b.n * a.d;
}

// // Overload the subscript operator for Fraction (returning numerator or denominator)
// op [] fn access_element(a: Fraction, index: int) -> int {
//     if index == 0 {
//         return a.n;
//     } else if index == 1 {
//         return a.d;
//     } else {
//         panic "Index out of bounds";
//     }
// }

// // Function call operator, which returns the fraction's value as a floating-point number
// op () fn fraction_to_float(a: Fraction) -> float {
//     return a.n as float / a.d as float;
// }
// TODO: references do not work
// Overload the stream insertion operator (for printing)
// op << fn stream_insert(out: std::ostream , a: Fraction) -> std::ostream {
//     return out << a.n << "/" << a.d;
// }

// Test the Fraction struct and operator overloads



// Recursive function to calculate factorial
fn factorial(n: int) -> int {
    if n <= 1:
        return 1;

    return n * factorial(n - 1);
}

const eval fn range(n: int) -> std::vector<int> {
    let v: std::vector<int>;

    for (let i: int = 0; i < n; i++) {
        v.push_back(i);
    }
    
    return v;
}

interface Foo {
    fn foo() -> int;
}

interface Bar derives Foo {
    fn bar() -> int;
}
class Fuzz {
    fn foo() -> int {
        return 0;
    }
}



class Fish requires <T> if Bar in T, T derives Fuzz {    
    let fish: T;
}




// fn fishy(f: Fish<T>) -> Fish<T> requires <T:Fizz> {
//     return f;
// }





// Function to print elements of a vector
// TODO: implement range-based for loop
fn print_vector(v: std::vector<int>) -> void {
    for i in range(v.size()) {
        printf("Vector element %d: %d\n", i, v[i]);
    }
}


class ABC {
    let a: int;
    let b: int;
    let c: int;

    fn ABC(self, a: int, b: int, c: int) {
        self.a = a;
        self.b = b;
        self.c = c;
    }

    fn print(self) -> void {
        printf("a: %d, b: %d, c: %d\n", self.a, self.b, self.c);
    }
}

fn main() -> int {
    // Adding two numbers
    let sum = add(5, 7);
    printf("Sum: %d\n", sum);

    // Calculating factorial
    let fact = factorial(5);
    printf("Factorial: %d\n", fact);

    // Working with a C++ vector
    let numbers: std::vector<int> = [1, 2, 3, 4];
    numbers.push_back(10);
    numbers.push_back(20);
    numbers.push_back(30);
    numbers.push_back(40);
    numbers.push_back(50);

    // Printing vector elements
    print_vector(numbers);

    // Using C++ std::string
    let greeting = std::string("Hello from Helix and C++!");
    std::cout << greeting << std::endl;

    // Conditional check
    if sum > fact {
        printf("Sum is greater than factorial.\n");
    } else {
        printf("Factorial is greater than or equal to sum.\n");
    }
    let f1:Fraction = Fraction { n=1, d= 2 };
    let f2:Fraction = Fraction { n= 3, d=4 };
    let f3 = f1 + f2;

    // Use C-style printf for output
    printf("f1: %d/%d\n", f1.n, f1.d);
    printf("f2: %d/%d\n", f2.n, f2.d);
    printf("f3 (f1 + f2): %d/%d\n", f3.n, f3.d);
    printf("f1 == f2: %s\n", f1 == f2 ? "True" : "False");

    // Accessing elements using the subscript operator
    // printf("f1 numerator (f1[0]): %d\n", f1[0]);
    // printf("f1 denominator (f1[1]): %d\n", f1[1]);

    // Calling the function call operator to get the fraction as float
    // printf("f1 as float: %f\n", f1());
    // Creating an object of class ABC
    let obj = ABC(10, 20, 30);
    obj.print();

    return 0;
}
