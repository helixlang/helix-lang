fn divide(parm1: &int, const parm2: i32) -> Exception? {
    // some implementation
}


fn main() {
    let x = 10;
    let y = 2;
    let result = divide(&x, y);
    
    if result != null {
        match typeof!(result) {
            DivideByZero -> println("Divide by zero error"),
            _            -> println("Unknown error")
        }
    } else {
        println("Result: ", x);
    }
}

/*

in the case devide's signature is `fn divide(parm1: &int, const parm2: i32) -> Exception?`
since the fucntion parm is a refrence, the caller MUST pass a refrence to the function
so the call should be `divide(&x, y);` instead of `divide(x, y);`

doing `divide(x, y);` would result in this error:
error: expected a reference to an 'int' but got a copy instead
    -->  at tests/main.hlx:1:4
   1 | let result? = divide(x, y);
     :               ~~~~~~~^~~~~
     |
  fix: change the call to `divide(&x, y);`

    note: the function definition is:
       -->  at tests/main.hlx:4:4
      4 | fn divide(parm1: &int, const parm2: i32) -> Exception? {
      5 |     if parm2 == 0 {
      6 |         return DivideByZero;

error: aborting due to previous error
```

*/