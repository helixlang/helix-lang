// Test: Advanced interfaces with generics, constraints, static methods, and fields

interface Foo requires <U> {
    fn foo(self) -> U;
}

interface Advanced requires <U> if U has Foo::<i32> {
    fn advanced_method(self) -> U;
    static fn advanced_static_method(value: U) -> U;
    let advanced_field: U;
}

// A class implementing Foo
class Bar extend Foo::<i32> {
    fn foo(self) -> i32 {
        return self.x;
    }

    let x: i32 = 10;
}

// A class implementing Advanced
class AdvancedBar extend Advanced::<Bar>
  requires <U> if U has Foo::<i32> {
    fn advanced_method(self) -> U {
        return self.advanced_field;
    }

    static fn advanced_static_method(value: U) -> U {
        return value;
    }

    let advanced_field: U;
}

fn main() -> i32 {
    // Test Advanced interface
    let advanced_instance = AdvancedBar::<Bar>{advanced_field = Bar{}};
    print(advanced_instance.advanced_method().foo()); // Should print 10
    
    // TODO: Fix scope path for generics before enabling this test
    // print(AdvancedBar::<Bar>::advanced_static_method(Bar{}).foo());
    return 0;
}

/*
--------- do not remove this comment, it is used by the test script to validate the output ---------
// START TEST
10
// END TEST
*/
