@ -0,0 +1,1760 @@
// todo make all non byte strings byte strings

// todo: formatter should be able to format macros, a macro can define what formatting to use
skel! {

    delimiters: b'{' | b'}' | b'(' | b')' | b';' | b'!' | b'=' | b'|'|b':'|b','|b'<'|b'>' | b'?'|b'.',
    // two char delimeters

    newline: b'\n',

    other_whitespace: b'\t' | b0xC | b'\r' | b' ',

    whitespace: other_whitespace!() | newline!(),
    // can use raw num bytes
    any: 0..=255,

/*
/*
"if"           : map({"internal_name": "IF"        , "parser": _unless      , "scoped": False, "has_body": True , "keyword_type": "control_flow"}),
"elif"         : map({"internal_name": "ELSE_IF"   , "parser": _unless      , "scoped": False, "has_body": True , "keyword_type": "control_flow"}),
"else"         : map({"internal_name": "ELSE"      , "parser": _unless      , "scoped": False, "has_body": True , "keyword_type": "control_flow"}),
"unless"       : map({"internal_name": "UNLESS"    , "parser": _unless      , "scoped": False, "has_body": True , "keyword_type": "control_flow"}),
"continue"     : map({"internal_name": "CONTINUE"  , "parser": _no_change   , "scoped": False, "has_body": False, "keyword_type": "loop_control"}),
"while"        : map({"internal_name": "WHILE"     , "parser": _no_change   , "scoped": False, "has_body": True , "keyword_type": "loop"}),
"for"          : map({"internal_name": "FOR"       , "parser": _for         , "scoped": True, "has_body":  True , "keyword_type": "loop"}),
"case"         : map({"internal_name": "CASE"      , "parser": dummy        , "scoped": False, "has_body": True , "keyword_type": "case_control"}),
"default"      : map({"internal_name": "DEFAULT"   , "parser": dummy        , "scoped": False, "has_body": True , "keyword_type": "case_control"}),
"switch"       : map({"internal_name": "SWITCH"    , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "case_control"}),
"match"        : map({"internal_name": "MATCH"     , "parser": dummy       , "scoped": False, "has_body": False, "keyword_type": "case_control"}),
"fn"           : map({"internal_name": "FUNCTION"  , "parser": _function    , "scoped": True , "has_body": True , "keyword_type": "function_declaration"}),
"lambda"       : map({"internal_name": "LAMBDA"    , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "function_declaration"}),
"thread"       : map({"internal_name": "THREAD"    , "parser": dummy        , "scoped": True , "has_body": True , "keyword_type": "function_declaration"}),
"macro"        : map({"internal_name": "MACRO"     , "parser": dummy        , "scoped": True , "has_body": True , "keyword_type": "function_declaration"}),
"async"        : map({"internal_name": "ASYNC"     , "parser": _function    , "scoped": False, "has_body": False, "keyword_type": "function_modifier"}),
"return"       : map({"internal_name": "RETURN"    , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "function_control"}),
"class"        : map({"internal_name": "CLASS"     , "parser": _class       , "scoped": True , "has_body": True , "keyword_type": "class_declaration"}),
"interface"    : map({"internal_name": "INTERFACE" , "parser": _class        , "scoped": True , "has_body": True , "keyword_type": "type_declaration"}),
"struct"       : map({"internal_name": "STRUCT"    , "parser": _class        , "scoped": True , "has_body": True , "keyword_type": "type_declaration"}),
"union"        : map({"internal_name": "UNION"     , "parser": _class        , "scoped": True , "has_body": True , "keyword_type": "type_declaration"}),
"enum"         : map({"internal_name": "ENUM"      , "parser": _class        , "scoped": True , "has_body": True , "keyword_type": "type_declaration"}),
"abstract"     : map({"internal_name": "ABSTRACT"  , "parser": _class        , "scoped": True , "has_body": True , "keyword_type": "class_modifier"}),
"try"          : map({"internal_name": "TRY"       , "parser":  dummy        , "scoped": False, "has_body": True , "keyword_type": "error_handling"}),
"catch"        : map({"internal_name": "CATCH"     , "parser":  dummy        , "scoped": False, "has_body": True , "keyword_type": "error_handling"}),
"except"        : map({"internal_name": "EXCEPT"   , "parser":  dummy        , "scoped": False, "has_body": True , "keyword_type": "error_handling"}),
"finally"      : map({"internal_name": "FINALLY"   , "parser":  dummy        , "scoped": False, "has_body": True , "keyword_type": "error_handling"}),
"throw"        : map({"internal_name": "THROW"     , "parser":  dummy        , "scoped": False, "has_body": False, "keyword_type": "error_handling"}),
"break"        : map({"internal_name": "BREAK"     , "parser":  _no_change   , "scoped": False, "has_body": False, "keyword_type": "core"}),
"delegate"     : map({"internal_name": "DELEGATE"  , "parser":  dummy        , "scoped": False, "has_body": False, "keyword_type": "core"}),
"with"         : map({"internal_name": "WITH"      , "parser":  _no_change   , "scoped": False, "has_body": True , "keyword_type": "core"}),
"private"      : map({"internal_name": "PRIVATE"   , "parser":  _function   , "scoped": False, "has_body": False, "keyword_type": "access_modifier"}),
"protected"    : map({"internal_name": "PROTECTED" , "parser":  _function   , "scoped": False, "has_body": False, "keyword_type": "access_modifier"}),
"public"       : map({"internal_name": "PUBLIC"    , "parser":  _function   , "scoped": False, "has_body": False, "keyword_type": "access_modifier"}),
"final"        : map({"internal_name": "FINAL"     , "parser":  _function   , "scoped": False, "has_body": False, "keyword_type": "access_modifier"}),
"static"       : map({"internal_name": "STATIC"    , "parser":  _function   , "scoped": False, "has_body": False, "keyword_type": "access_modifier"}),
"unsafe"       : map({"internal_name": "UNSAFE"    , "parser":  _function   , "scoped": False, "has_body": False, "keyword_type": "access_modifier"}),
"let"          : map({"internal_name": "LET"       , "parser": _let         , "scoped": False, "has_body": False, "keyword_type": "variable_declaration"}),
"const"        : map({"internal_name": "CONST"     , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "variable_declaration"}),
"var"          : map({"internal_name": "VAR"       , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "variable_declaration"}),
"include"      : map({"internal_name": "IMPORT"    , "parser": _include     , "scoped": False, "has_body": False, "keyword_type": "module_import"}),
"import"       : map({"internal_name": "IMPORT"    , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "module_import"}),
"using"        : map({"internal_name": "USING"     , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "module_import"}),
"from"         : map({"internal_name": "FROM"      , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "module_import"}),
"yield from"   : map({"internal_name": "YIELD_FROM", "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "asynchronous_control"}),
"yield"        : map({"internal_name": "YIELD"     , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "asynchronous_control"}),
"await"        : map({"internal_name": "AWAIT"     , "parser": dummy        , "scoped": False, "has_body": False, "keyword_type": "asynchronous_control"}),
*/ // Control Flow
    IF                 {  scoped: false, has_body: true  ,ident:"if", doc:"The if keyword"                   },
    UNLESS             { scoped: false, has_body: true , ident:"elif"     , doc: "The unless keyword, like elif" },
    ELSE               { scoped: false, has_body: true , ident:"else"     , doc: "The else keyword"              },

    // Loops
    WHILE              { scoped: false, has_body: true , ident:"while"    , doc: "The while keyword"             },
    FOR                { scoped: true , has_body: true , ident:"for"      , doc: "The for keyword"               },
    //LOOP      { scoped: false, has_body: true, ident:"loop" , doc: "An endless loop" },
    // post test loop needed


    // Pattern Matching
    CASE               { scoped: false, has_body: true , ident:"case"     , doc: "The case keyword" },
    DEFAULT            { scoped: false, has_body: true , ident:"default"  , doc: "The default keyword" },
    MATCH              { scoped: false, has_body: false, ident:"match"    , doc: "The match keyword" },
    SWITCH             { scoped: false, has_body: false, ident:"switch"   , doc: "The switch keyword" },

    // Loop Control
    BREAK              { scoped: false, has_body: false, ident:"break"   , doc: "The break keyword"          },
    CONTINUE           { scoped: false, has_body: false, ident:"continue", doc: "The continue keyword"       },

    // Function Declaration
    FUNCTION           { scoped: true , has_body: true , ident:"fn"       , doc: "The function keyword" },
    ANONYMOUS_FUNCTION { scoped: true , has_body: true , ident:"lambda"   , doc: "The lambda keyword" },

    // Threading
    THREAD             { scoped: true , has_body: true , ident:"thread"   , doc: "The thread keyword" },

    // Meta Programming
    MACRO              { scoped: true , has_body: true, ident:"macro"    , doc: "The macro keyword" },
    OPERATOR           { scoped: true , has_body: true, ident:"operator" , doc: "The operator keyword" },


    // Function Modifier
    ASYNC              { scoped: false, has_body: false, ident:"async"    , doc: "Denotes an asynchronous function" },
    DELEGATE           { scoped: false, has_body: false, ident:"delegate" , doc: "The delegate keyword" },
    //INLINE             { scoped: false, has_body: false, ident:"inline"   , doc: "Denotes an inline function" },

    // Function Control
    RETURN             { scoped: false, has_body: false, ident:"return"   , doc: "Returns a value from a function" },

    // Data Structures
    CLASS              { scoped: true , has_body: true , ident:"class"     , doc: "The class keyword" },
    STRUCT             { scoped: true , has_body: true , ident:"struct"    , doc: "A type structure without methods" },
    ENUM               { scoped: true , has_body: true , ident:"enum"      , doc: "An enum" },
    UNION              { scoped: true , has_body: true , ident:"union"     , doc: "A union" },


    // Type Declarations
    INTERFACE          { scoped: true , has_body: true , ident:"interface", doc: "An interface without default methods" },
    ABSTRACT           { scoped: true , has_body: true , ident:"abstract" , doc: "An interface with default methods" },
    TYPE               { scoped: false, has_body: false, ident:"type"     , doc: "A type alias" },

    // Type Handling
    TYPEOF             { scoped: false, has_body: false, ident:"typeof"    , doc: "Returns the type of a variable" },
    SIZEOF             { scoped: false, has_body: false, ident:"sizeof"    , doc: "Returns the size of a type in bytes" },
    INSTANCEOF         { scoped: false, has_body: false, ident:"instanceof", doc: "Checks if a variable is an instance of a type" }, // not sure about this


    // Error Handling

    TRY                { scoped: false, has_body: true , ident:"try"      , doc: "The try keyword" },
    CATCH              { scoped: false, has_body: true , ident:"catch"    , doc: "The catch keyword" },
    EXCEPT             { scoped: false, has_body: true , ident:"except"   , doc: "The except keyword" },
    FINALLY            { scoped: false, has_body: true , ident:"finally"  , doc: "The finally keyword" },
    THROW              { scoped: false, has_body: false, ident:"throw"    , doc: "Throws an error" },

    // // Core
    // with      { scoped: false, has_body: true  },

    // Access Modifier
    PRIVATE            { scoped: false, has_body: false, ident:"private"  , doc: "Accessible from a data structure only" },
    PROTECTED          { scoped: false, has_body: false, ident:"protected", doc: "Accessible from a data structure and its children" },
    PUBLIC             { scoped: false, has_body: false, ident:"public"   , doc: "Accessible from anywhere" },
    CONST              { scoped: false, has_body: false, ident:"const"    , doc: "A compile time constant" },
    FINAL              { scoped: false, has_body: false, ident:"final"    , doc: "A runtime constant, once set cannot be changed" },
    STATIC             { scoped: false, has_body: false, ident:"static"   , doc: "Denotes interior mutability" },
    UNSAFE             { scoped: false, has_body: false, ident:"unsafe"   , doc: "Notates Undefined Behavior" },

    // Variable Declaration
    LET                { scoped: false, has_body: false, ident:"let"      , doc: "A mutable variable" }, // should use let mut ...
    VAR                { scoped: false, has_body: false, ident:"var"      , doc: "The var keyword" },
    AUTO               { scoped: false, has_body: false, ident:"auto"     , doc: "A variable with automatic type inference" }, 

    // Module Import
    IMPORT             { scoped: false, has_body: false, ident:"import"   , doc: "Imports a module" },
    INCLUDE            { scoped: false, has_body: false, ident:"include"  , doc: "Includes a file" },
    USING              { scoped: false, has_body: false, ident:"using"    , doc: "Uses a module" },
    FROM               { scoped: false, has_body: false, ident:"from"     , doc: "Imports a module from a package" },

    // Asynchronous Control
    YIELD              { scoped: false, has_body: false, ident:"yield"    , doc: "Yields a value from a generator" },
    AWAIT              { scoped: false, has_body: false, ident:"await"    , doc: "Waits for an asynchronous function to complete" }
    

}
*/
    
    group keyword {
        // Control Flow

        /// The if keyword
        statement IF:Keyword = "if";
        statement UNLESS:Keyword = "unless"; /// The unless keyword, like elif
        statement ELIF:Keyword = "elif"; /// The else keyword
        statement ELSE:Keyword = "else"; /// The else keyword

        // Loops
        statement WHILE:Keyword = "while"; /// The while keyword
        statement FOR:Keyword = "for"; /// The for keyword
        statement LOOP:Keyword = "loop"; /// An endless loop

        // Pattern Matching
        statement CASE:Keyword = "case"; ///  The case keyword
        statement DEFAULT:Keyword = "default"; /// The default keyword
        statement MATCH:Keyword = "match" /// The match keyword
        statement SWITCH:Keyword = "switch"; /// The switch keyword

        // Loop Control
        statement BREAK:Keyword = "break"; /// The break keyword
        statement CONTINUE:Keyword = "continue"; /// The continue keyword

        // Function Declaration
        statement FUNCTION:Keyword = "fn"; /// The function keyword
        statement ANONYMOUS_FUNCTION:Keyword = "lambda"; /// The lambda keyword

        // Threading
        statement THREAD:Keyword = "thread"; /// The thread keyword
        statement TENSOR:Keyword = "tensor"; /// The tensor keyword

        // Meta Programming
        statement MACRO:Keyword = "macro"; /// The macro keyword
        statement OPERATOR:Keyword = "op"; /// The operator keyword

        // Function Modifier
        statement ASYNC:Keyword = "async"; /// Denotes an asynchronous function
        statement DELEGATE:Keyword = "delegate"; /// The delegate keyword
        statement INLINE:Keyword = "inline"; /// Denotes an inline function

        // Function Control
        statement RETURN:Keyword = "return"; /// Returns a value from a function

        // Data Structures
        statement CLASS:Keyword = "class"; /// The class keyword
        statement STRUCT:Keyword = "struct"; /// A type structure without methods
        statement ENUM:Keyword = "enum"; /// An enum
        statement UNION:Keyword = "union"; /// A union

        // Type Declarations
        statement INTERFACE:Keyword = "interface"; /// An interface without default methods
        statement ABSTRACT:Keyword = "abstract"; /// An interface with default methods
        statement TYPE_ALIAS:Keyword = "type"; /// A type alias

        // Type Handling
        statement TYPEOF:Keyword = "typeof"; /// Returns the type of a variable
        statement SIZEOF:Keyword = "sizeof"; /// Returns the size of a type in bytes
        statement INSTANCE_OF:Keyword = "instance_of"; /// Checks if a variable is an instance of a type

        // Error Handling
        statement TRY:Keyword = "try"; /// The try keyword
        statement CATCH:Keyword = "catch"; /// The catch keyword
        statement EXCEPT:Keyword = "except"; /// The except keyword
        statement FINALLY:Keyword = "finally"; /// The finally keyword
        statement THROW:Keyword = "throw"; /// Throws an error

        // Core
        statement WITH:Keyword = "with"; /// The with keyword

        // Access Modifier
        statement PRIVATE:Keyword = "private"; /// Accessible from a data structure only
        statement PROTECTED:Keyword = "protected"; /// Accessible from a data structure and its children
        statement PUBLIC:Keyword = "public"; /// Accessible from anywhere
        statement CONST:Keyword = "const"; /// A compile time constant
        statement FINAL:Keyword = "final"; /// A runtime constant, once set cannot be changed
        statement STATIC:Keyword = "static"; /// Denotes interior mutability
        statement UNDEF:Keyword = "undef"; /// Notates Undefined Behavior

        // Variable Declaration
        statement LET:Keyword = "let"; /// A mutable variable
        statement VAR:Keyword = "var"; /// The var keyword
        
        // Assignment modifiers
        statement AUTO:Keyword = "auto"; /// A variable with automatic type inference, let auto x = 3;
        statement AWAIT:Keyword = "await"; /// Waits for an asynchronous future to complete when assigned to a variable, let await x = async_fn();

        // Module Import
        statement IMPORT:Keyword = "import"; /// Imports a module
        statement INCLUDE:Keyword = "include"; /// Includes a file
        statement USING:Keyword = "using"; /// Uses a module
        statement FROM:Keyword = "from"; /// Imports a module from a package

        // Asynchronous Control
        statement YIELD:Keyword = "yield"; /// Yields a value from a generator
        // should be a modifier like let await 3= ...
        // and .await




    }




    builtin rule peek(pattern:Pattern) -> bool
    builtin rule LineStart;
    builtin rule LineEnd;

    builtin quantifier * = 0..;
    builtin quantifier + = 1..;
    builtin quantifier ? = 0..1;


    rule LineStart = if peek



    // todo: goto keyword

    template Delimit(start: Literal, middle: Pattern, end?: Literal = start)-> Pattern {
        start middle end
    }


    template SquareBrackets(middle:Pattern) {
        Delimit(b'[',middle,b']')
    };

    
    
    template Parentheses(middle:Pattern) -> Delimit(b'(',middle,b')');
    template CurlyBrackets(middle:Pattern) -> Delimit(b'{',middle,b'}');
    template AngleBrackets(middle:Pattern) -> Delimit(b'<',middle,b'>');


    template SeparatedList(pattern:Pattern, separator:Pattern, optional_trailing:bool) -> Pattern {
        (self::pattern self::separator)* if optional_trailing {self::pattern?}
    }

    template CommaSeparated(pattern:Pattern,optional_trailing:bool) -> Separated(self::pattern, b',', self::optional_trailing);
    template SemicolonSeparated(pattern:Pattern,optional_trailing:bool) -> Separated(self::pattern, b';', self::optional_trailing);

    template RoundList(middle:Pattern) -> Parentheses(SeparatedList(self::middle, b',', true));
    template SquareList(middle:Pattern) -> SquareBrackets(SeparatedList(self::middle, b',', true));
    template CurlyList(middle:Pattern) -> CurlyBrackets(SeparatedList(self::middle, b',', true));
    template AngleList(middle:Pattern) -> AngleBrackets(SeparatedList(self::middle, b',', true));

    template Tuple(elements:Type) as Type -> RoundList(elements);
    template Tuple(elements:Expression) as Expression -> RoundList(elements);




    // TODO: need a way to type an array
    template Array(elements:Expression) as Expression -> SquareList(elements);

    


    pattern Identifier {

        first: Alpha | Underscore,
        rest: self::first | Numeric,

        Identifier() -> {
            self::first self::rest*
        }
    }

    pattern TypeGeneric {
        name: Identifier,
        generics: AngleList(Type),

        TypeGeneric() {
            self::name self::generics?
        }
    }

    pattern Type {
        group name: Identifier,
        generics: TypeGeneric,

        Type() -> {
            self::name self::generics?
        }
    }

    group Type {
        name: Identifier,
    }

    abstract 
    

    group 


    // {{}}}{{{}{}}{}}}



    
    // var a = 3

    // func something()
    // {
    //     a++
    // }
    
    // return 3 + something() + a 

    
    // CustomIdentifier
    // uint64_t CIInt = ToRuntimeIdentifier("CustomIdentifier")

    // struct MatchData {
    //     char* start
    //     char* end
    //     uint8_t encoding
    // }

    // int i = 0;
    // int* p = &i;
    // return p;



    // struct MatchCase
    // {
    //     uint64_t identifier // this can be computed at compile time
    //     MatchData data
    //     MatchCase* children
    // }





    // {func();}
    // {
    //     0xdead
    //     0x00
    //     0x01
    //     0x02

    // }
    // {
    //     0xc0de
    //     0x02
    //     0x03
    //     0x00
    // }
    // [match1, match2, match3]

    group Name {

        things
    }
    
  
    agnostic pattern SquareBrackets<middle> : Parent[Delimit('"' ,middle, '"')]


    abstract pattern AbstractSearcher<start: Pattern, middle:Pattern ,end?: Pattern = start>
    {
        start;
        middle;
        end;
    }

    SquareBrackets foo = ...;

    foo.start

    pattern SquareBrackets : AbstractSearcher<'[', any, ']'> {}
        

    
    pattern TypedAssignmentTernary {
        
        type_specifier?: if self::has_type { ':' self::type } 
        assignment?: if self::HAS_ASSIGNMENT {'=' self::value},
        type_part?: if self::TYPE_OPTIONAL self::type_specifier? else self::type_specifier

        TypedAssignmentTernary(name:Identifier, type:Pattern, value:Pattern, TYPE_OPTIONAL:bool; HAS_TYPE:bool, HAS_ASSIGNMENT:bool ) -> {
            self::name self::type_part self::assignment
        }
    }


    // this is later
    // pattern InlineMetaAttribute {
    //     name: Identifier,
        

    //     MetaAttribute() -> {
    //         self::name 
    //     }
    // }



    pattern VariableDefinition(name:Identifier, type:Type, value:Expression)-> TypedAssignmentTernary(self::name, self::type, self::value, false, true);



    pattern GenericDefinition {

        name: Identifier,

        generic_item: TypedAssignmentTernary(Identifier, Type, Type),

        generics: AngleList(self::generic_item),

        GenericDefinition() {
            self::name self::generics
        }
    }






    pattern TypeAlias {
        keyword = Keyword(keyword::TYPE)
        name: Identifier,
        bounds: TypeGeneric,
        generics: GenericDefinition,
        setting:TypedAssignmentTernary(self::name self::generics, self::bounds, Type),

        TypeAlias() -> {
            self::keyword self::setting
        }
    }

    /*
    #[meta(...)]
        
        #[meta(...)]
     
        #[protocol(
        error = "TestError",
        fields((
            // if version is not specified it will default to the latest version
            java(encoding = "be"),
            bedrock(encoding = "le")
        ),
        (
            java(encoding = "var"),
            bedrock(encoding = "zigzag")
        ),
        (
            java(version = "2..34",len = "u8", inner(len = "u32_var") ),
            bedrock(version = "3..22",len = "u8",inner(len = "u32_be"))
        )
        )
    )]
     
     */

    
    pattern Meta {
        name: Identifier,
        values:SquareListList(TypedAssignmentTernary(Identifier, Type, Expression)),

        Meta() -> {
            self::keyword self::name self::values
        }
    }



    pattern KeywordHeader {
        keyword = self::
        name: Identifier,
        generics: AngleList(Type),


        KeywordHeader(keyword:string) -> {
            self::keyword self::name self::generics
        }
    }



    pattern Struct {
        keyword = Keyword(keyword::STRUCT),
        name: Identifier,
        generics: AngleList(Type),
        fields: CurlyList(VariableDefinition),

        Struct() -> {
            self::keyword self::name self::generics self::fields
        }
    }



    pattern Function {
        keyword: Keyword(keyword::FUNCTION),
        name: Identifier,
        parameters: RoundList(VariableDefinition, b',', true),
        return_type: Type,
        return_operator: ,
        body: ,

        Function() -> {
            self::keyword self::name self::parameters self::return_type self::body
        }
    }


    //pattern Indexing(index:Pattern) -> SquareBrackets(index);




    // enum QuotePrefix {
    //     Raw: "r",
    //     Binary: "b",
    //     Unicode: "u",
    //     Formatted: "f",
    // }




    pattern Quotes(prefix:QuotePrefix, inner:Pattern) ->{Delimit('"',middle)};




    // struct DoubleQuotes<MIDDLE>: Delimit<b'"',MIDDLE,b'"'> {
    //     middle: MIDDLE
    // },








    /// A patten that contains all the different types of patterns
    quantifier All;
    quantifier AtLeastOne;
    quantifier ZeroOrOne;

    /// Some Sort of Pattern
    statement Pattern

    /// States that the pattern is optional at the end
    statement OptionalAtEnd<>

    statement RequiredAtEnd

    abstract Separator<PAT,LIT> {
        pattern: Pattern = PAT,
        separator: Literal = LIT,
        layout() -> {
            self::pattern self::separator
        }
    },



    /// Required Whitespace
    pat HorizontalWhitespace:Literal = b' ' | b'\t' | b'\r' | b0xC;
    struct VerticalWhitespace:Literal = b'\n';

    pat Whitespace:Literal = HorizontalWhitespace | VerticalWhitespace;



    /// A structure that

    abstract SeparatedGroup<PAT,SEPARATOR,START,END,END_REQUIRED>: Delimit<START,Separator<PAT,SEPARATOR>,END>{

    }



    statement Expression:Pattern;

    struct Brace<REQUIRED_KEYWORD[]>: SeparatedGroup<Expression, ";", "{", "}", true> {

        required_keyword: REQUIRED_KEYWORD


    };

    alias CommaList<Pat,Start>: SeparatedGroup<Pat, OptionalAtEnd<",">>;

    /// A pattern that is a literal
    statement Literal: Pattern;



    interface List:SeparatedGroup {

    },


    scope:SeparatedGroup {
        start: '{',
        end: '}',
        separator: ';',
        // like a fn scope can contain return, break, continue, and other scopes
        can_contain(pattern:Pattern) -> {
            pattern
        }
    },
    /// Notates that something is a type declaration
    statement Type:Pattern;




    structure: {

    }



    scope : {
        start: '{',
        end: '}',
        separator: ';',
        // like a fn scope can contain return, break, continue, and other scopes
        can_contain(pattern:Pattern) -> {
            pattern
        }
    }


    pattern Keyword {
        ident: Identifier,

        Keyword() -> {
            self::ident ansi::Whitespace
        }
    }

    abstract Pattern: {
        // Operator-specific documentation must be defined in subclasses
        fn doc(&self) -> String;
    }


    inbuilt {
        abstract Pattern;

        abstract Literal extends Pattern;
        abstract String extends Literal;
        abstract Number extends Literal;
        abstract Char extends Literal;
        abstract Boolean extends Literal;
    }

    group math {
        use super::ansi::punctuation::{Plus, Minus, Asterisk, Slash, Percent, CircumflexAccent,
            CommercialAt, Ampersand,Not, VerticalLine, Tilde, Dollar, Hash, GraveAccent,
            LowLine, Bang, Colon, Semicolon, LessThan, GreaterThan, Equals};

        alias Add: Plus;
        alias Subtract: Minus;
        alias Multiply: Asterisk;
        alias Divide: Slash;
        alias Modulo: Percent;
        alias Power: CircumflexAccent;
        alias Factorial: Bang;
        alias BitwiseAnd: Ampersand;
        alias BitwiseOr: VerticalLine;
        alias BitwiseXor: Tilde;
        pattern BitwiseNot: Not | Bang;
        alias MatrixMultiply: CommercialAt;

        alias GreaterThan: GreaterThan;
        alias LessThan: LessThan;

        pattern GreaterThanOrEqualTo: GreaterThan+Equals;
        pattern LessThanOrEqualTo: LessThan + Equals;
        pattern EqualTo: Equals+Equals;

        /// The not equal to operator
        pattern NotEqualTo: Bang + Equals;

        /// The strict equal to operator
        pattern StrictEqualTo: Equals + Equals + Equals;

        /// The strict not equal to operator
        pattern StrictNotEqualTo: Bang + Equals + Equals;

        /// The assignment operator
        alias Assign: Equals;

        pattern AddAssign: Plus + Equals;
    }

    group brackets {
        group round {
            use super::punctuation::{LeftParenthesis, RightParenthesis};
            alias Open: LeftParenthesis;
            alias Close: RightParenthesis;
        }
        group square {
            use super::punctuation::{LeftBracket, RightBracket};
            alias Open: LeftBracket;
            alias Close: RightBracket;
        }

        group curly {
            use super::punctuation::{LeftCurlyBracket, RightCurlyBracket};
            alias Open: LeftCurlyBracket;
            alias Close: RightCurlyBracket;
        }

        group angle {
            use super::punctuation::{LessThan, GreaterThan};
            char Open: LessThan;
            char Close: GreaterThan;
        }
    }


    group ansi {


        enum Control {
            Null: 0x0;
            Enquiry: 0x5;
            Acknowledge: 0x6;
            Bell: 0x7;
            Backspace: 0x8;
            LineFeed: '\n';
            VerticalTab: 0xB;
            FormFeed: 0xC;
            CarriageReturn: '\r';
            ShiftOut: 0xE;
            ShiftIn: 0xF;
            DataLinkEscape: 0x10;
            DeviceControlOne: 0x11;
            DeviceControlTwo: 0x12;
            DeviceControlThree: 0x13;
            DeviceControlFour: 0x14;
            NegativeAcknowledge: 0x15;
            SynchronousIdle: 0x16;
            EndOfTransmissionBlock: 0x17;
            Cancel: 0x18;
            EndOfMedium: 0x19;
            Substitute: 0x1A;
            Escape: 0x1B;
            FileSeparator: 0x1C;
            GroupSeparator: 0x1D;
            RecordSeparator: 0x1E;
            UnitSeparator: 0x1F;
            Delete: 0x7F;
        }

        use Control::{Tab, LineFeed, CarriageReturn, FormFeed, VerticalTab, Space};

        enum Whitespace {
            Newline: LineFeed;
            Return: CarriageReturn;
            HorizontalTab: Tab;
            VerticalTab: VerticalTab;
            FormFeed: FormFeed;
            Space: ' ';
        }

        enum Punctuation {
            CommercialAt: '@';
            Backslash: '\\';
            CircumflexAccent: '^';
            Underscore: '_';
            GraveAccent: '`';
            VerticalLine: '|';
            Tilde: '~';
            Bang: '!';
            DoubleQuote: '"';
            Hash: '#';
            Dollar: '$';
            Percent: '%';
            Ampersand: '&';
            SingleQuote: '\'';
            LeftParenthesis: '(';
            RightParenthesis: ')';
            Asterisk: '*';
            Plus: '+';
            Comma: ',';
            Minus: '-';
            Period: '.';
            Slash: '/';
            Colon: ':';
            Semicolon: ';';
            LessThan: '<';
            Equals: '=';
            GreaterThan: '>';
            Question: '?';
            LeftBracket: '[';
            RightBracket: ']';
            LeftCurlyBracket: '{';
            RightCurlyBracket: '}';
            Not:'¬';
        }



        enum LatinCapital {
            A: 'A';
            B: 'B';
            C: 'C';
            D: 'D';
            E: 'E';
            F: 'F';
            G: 'G';
            H: 'H';
            I: 'I';
            J: 'J';
            K: 'K';
            L: 'L';
            M: 'M';
            N: 'N';
            O: 'O';
            P: 'P';
            Q: 'Q';
            R: 'R';
            S: 'S';
            T: 'T';
            U: 'U';
            V: 'V';
            W: 'W';
            X: 'X';
            Y: 'Y';
            Z: 'Z';
        }

        enum LatinSmall {
            A: 'a';
            B: 'b';
            C: 'c';
            D: 'd';
            E: 'e';
            F: 'f';
            G: 'g';
            H: 'h';
            I: 'i';
            J: 'j';
            K: 'k';
            L: 'l';
            M: 'm';
            N: 'n';
            O: 'o';
            P: 'p';
            Q: 'q';
            R: 'r';
            S: 's';
            T: 't';
            U: 'u';
            V: 'v';
            W: 'w';
            X: 'x';
            Y: 'y';
            Z: 'z';
        }

        enum Digits {
            Zero: '0';
            One: '1';
            Two: '2';
            Three: '3';
            Four: '4';
            Five: '5';
            Six: '6';
            Seven: '7';
            Eight: '8';
            Nine: '9';
        }

        pattern Alpha: LatinCapital | LatinSmall;
        pattern Alphanumeric: Alpha | Numeric;
        alias Numeric: Digits;

        pattern HorizontalWhitespace: Whitespace::Space | Whitespace::Tab | Whitespace::CarriageReturn | Whitespace::FormFeed | Whitespace::VerticalTab;
        pattern VerticalWhitespace: Whitespace::Newline;

        // these have to be very explicit
    }

    use ansi::{Alpha,Whitespace,Numeric,Punctuation::{self,Underscore,Period,DoubleQuote}};
















    pattern Type: Pattern {
        name: Identifier,
        generics: Delimit<CommaList<Type>>,

        Type() -> {
            self::name self::generics?
        }
    }







    marker Primitive: Pattern;

    pattern String: Delimit<DoubleQuote, All> + Primitive {
        fn skip() -> {
            self::backslash super::start
        }
    }

    pattern Char: Delimit<SingleQuote, All> + Primitive {
        fn skip() -> {
            self::backslash super::start
        }
    }

    group number {

        use super::ansi::{Numeric,Period,Alphanumeric};


        enum Prefix {
            Binary: "0b",
            Octal: "0o",
            Hexadecimal: "0x",
        }

        enum Endian {
            Little: "le",
            Big: "be",
            Native: "ne",
        }

        enum IntegerSuffix {
            u8: "u8",
            u16: "u16",
            u32: "u32",
            u64: "u64",
            u128: "u128",
            i8: "i8",
            i16: "i16",
            i32: "i32",
            i64: "i64",
            i128: "i128",
        }

        enum FloatSuffix {
            f32: "f32",
            f64: "f64"
        }


        /// The exponent part of a number
        pattern Exponent {
            e: ansi::LatinCapital::E | ansi::LatinSmall::E
            sign: math::Add | math::Subtract,
            multiplier: Numeric+,

            Exponent() -> {
                self::e self::sign? self::multiplier
            }
        }

        pattern Binary:Literal {
            prefix: Prefix::Binary,
            number: Numeric,

            Binary() -> {
                self::prefix self::number
            }
        }

        const MAX_INT_SIZE = 128;


        enum NumberFormat {
            Decimal: Numeric+,
            Binary: "0b" + ('1' | '0'){1,MAX_INT_SIZE},
            Octal: "o" + ('0'..'7'){1,MAX_INT_SIZE/8},
            Hexadecimal: "x",
        }


        pattern Float:Literal {
            negative: math::Subtract,
            number: ,
            fractional:  Numeric+,
            exponent: Exponent,
            dot:Period,
            suffix: FloatSuffix,

            Float() -> {
                self::negative? self::integer?  (self::dot self::fractional)? self::exponent? self::suffix?
            }
        }

        enum NumberDelimiter {
            Comma: ',',
            Underscore: '_',
        }


        pattern Number:Literal {
            integer: Numeric+,
            fractional: Period Numeric+,
            exponent: Exponent,

            Number() -> {
                self::integer self::fractional? self::exponent?
            }
        }

        pattern Integer:Literal {
            decimal:Prefix
            layout() -> {
                self::decimal | self::binary | self::octal | self::hexadecimal
            }
        }







    }



    /// A boolean value
    pattern Boolean: Literal {
        true: "true",
        false: "false",
        layout() -> {
            self::true | self::false
        }
    }

    abstract VariableDefinition



    group function {
        abstract Function extends Pattern {
            // like inline or static
            meta: Pattern[],
            name: Identifier?,
            parameters: Delimit<CommaList<VariableDefinition>>,
            return_type: Type,
            body: Brace<Pattern>,
        }




    }


    group operator {

        meta Expression is builtin::Pattern;

         // Abstract base class for operators to avoid redundancy
        abstract Operator is Pattern {
            symbol: Pattern;
            identifier: Pattern;
            type: OperatorType;
            precedence: number;
            associativity: Associativity;

            // converts the op to a function call.
            fn to_function() -> {
                self::identifier function::call
            }
        }

        abstract PrefixOperator{

            rhs: Expression,
            operator: Operator,

            Prefix(identifier:Pattern, symbol:Pattern,  precedence:Number) -> {
                self::operator {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::RightToLeft,
                };
            }





        }




        // what do i call this type of operator |x| where it is surrounded by two things





        abstract PrefixExpression is OperatorExpression {
            PrefixExpression() {
                operator: Prefix,
                lhs: Expression,
            }
        }

        abstract Infix is OperatorExpression {
            Infix() {
                operator: Operator,
                lhs: Expression,
                rhs: Expression,
            }
        }


        abstract Prefix is Operator {
            Prefix( identifier:Pattern, symbol:Pattern,  precedence:Number) -> {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::RightToLeft,
                };

                self
            }
        }




        abstract Infix is Operator {

            rhs: Expression,
            lhs: Expression,


            Infix() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Binary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };
                self::lhs super self::rhs
            }
        }

        abstract Postfix is Operator {

            Postfix() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };

                self::lhs super
            }
        }





        abstract Ternary<RHO,LHO> is Operator {
            rhs: RHO,
            lhs:


            Ternary() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Ternary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };

                self::lhs super self::middle super self::rhs
            }
        }




        /// The type of operator
        enum OperatorType {
            // Binary operators take two operands
            Binary,
            // Unary operators take one operand
            Unary,
            // Ternary operators take three operands
            Ternary,
        }

        enum Associativity {
            /// Evaluates from left to right
            LeftToRight,
            /// Evaluates from right to left
            RightToLeft,
        }

        /// Assigns the value of the right operand to the left operand.
        struct Assignment is Operator {
            symbol: super::math::Assign,
            type: OperatorType::Binary,
            precedence: 1,
            associativity: Associativity::RightToLeft,
        }

        struct EqualTo is Operator {
            symbol: "==",
            type: OperatorType::Binary,
            precedence: 2,
            associativity: Associativity::LeftToRight,
            doc: "Checks if the left operand is equal to the right operand",
        }



    }



    variable: {

        prefix: {
            mutable:{
                def: "~" |"mutable",
                layout() -> {
                    self
                }
            },
            macro_invocation: {},
            static: "static",
            const: "const",

        },


        defined_as: ":",

        layout() -> {
            self::prefix super::identifier self::defined_as super::type
        }
    },



    function : {
        keyword: "fn",

        param : {
            start: '(',
            end: ')',
            suffix: {
                error: '?',
                layout() {// declares the order
                    error
                }
            }

            middle*: {
                separator:','

                layout() -> {
                    ::variable self::separator*?  // optional end is *?
                }
            }

            layout() -> {
                self::start self::middle*? self::end self::suffix
            }



        },


        layout() -> {
            self::keyword self::param self::return error
        }

    },

    variable_definition : {
        // let ...
    }

    fn fizz_bizz (ffo:u8,f:u8)

    variable_type: {
        start: b":",
        end: b";",
        separator: b",",
    },

    method : {
        instance_call: b'.',
        static_call: b"::",
    },




    macro: {
        call: b'!',
    }




    fn_call_suffixes: macro_call!(),

    string_quotes: b'"',
    char_quotes: b'\'',

    quotes: string_quotes!() | char_quotes!(),

    backslash: b'\\',

    // raw | binary | unicode | formatted
    quote_prefixes: b'r' | b'b'| b'u'| b'f',
    // TODO: integrate this here ^
    prefixed_quotes: b"r\"" | b"b\""| b"u\""| b"f\"",

    // escape sequences
    // should we include regexp escape sequences in helix?
    // newline | carriage return | tab | null | hex | unicode | unicode extended | single quote
    escape_sequences: b"\\n" | b"\\r" | b"\\t" | b"\\0" | b"\\x" | b"\\u" | b"\\U" | b"\\'",


    two_len_ops: b"==" | b"!=" | b"<=" | b">=" | b"//" | b"**" |
    b"<<" | b">>" | b"r+" | b"r-"| b"r*" | b"r/" | b"r%" | b"r&" | b"r|" |
    b"r^" | b"+=" | b"-=" | b"*=" | b"/=" | b"%=" | b"&=" | b"|=" | b"^=" |
    b"=>" | b"@=" | b"->" | b"<-" | b"<=" | b">=" | b"&&" | b"--" |
    b"::" | b"||" | b"++" | b"__" | b"?=",



    three_len_ops: b"===" | b"!==" | b"..." | b"r//" | b"r**" | b"r<<" | b"r>>" | b"//=" | b"**=" | b"<<=" |
    b">>=" | b"??" | b"|:",

    // hex: numeric!() | b'a'..=b'f' | b'A'..=b'F',


    // method_call: b'.',
    // static_method_call: b"::",
    // method_error: b'?',


    // fn_definition_error_suffix: b'?',
    // fn_definition_suffixes: fn_definition_error_suffix!(),


    // fn_definition: b"fn",

    // // used for match statements
    // implies: b"=>",

    // fn_error: b'?',
    // // idk abt this copiolet gave this : fn_error_eq: b"?=",

    // fn_return: b"->",

    // fn_param_start: b'(',
    // fn_param_end: b')',

    // scope_start: b'{',
    // scope_end: b'}',

    // array_start: b'[',
    // array_end: b']',

    // tuple_start: b'(',
    // tuple_end: b')',

    // // make thing that does this

    // // numeric_prefix : {
    // //     // all of these patterns are in numeric prefix and also their own patterns that  can be used...
    // //     ordinal: b'o',
    // // }


    // // idk about big O
    // ordinal_numeric:b'o' ,

    // // little b is
    // binary_numeric: b'b',

    // // u is unicode. u4u32 would make it into the respective type from that char to the number
    // unicode_numeric: b'u',
    // numeric_hex: b'x' | b"0x",

    // big_endian: b'b',
    // little_endian: b'l',
    // native_endian: b'n',

    // numeric_endian_infixes: big_endian!() | little_endian!() | native_endian!(),
    // numeric_prefixes: ordinal!() |  binary_numeric!(),

    underscore: b'_',
    uppercase: b'A'..=b'Z',
    lowercase: b'a'..=b'z',
    numeric: b'0'..=b'9',

    alphanumeric: lowercase!() | uppercase!() | numeric!(),



    identifier: {
        prefix:{
            raw: b"r\"", // idk about this
        }
        first_char: lower_case!() | uppercase!() | underscore!(),
        rest: alphanumeric!() | underscore!(),

        layout() -> {
            first_char rest
        }
    },

    punctuation: b'!'..=b'/'|b':'..=b'@'|b'['..=b'`'|b'{'..=b'~',

    //TODO: make work -> operators: two_char_operators!() | three_char_operators!()

    operators:  b"==" | b"!=" | b"<=" | b">=" | b"//" | b"**" |
    b"<<" | b">>" | b"r+" | b"r-"| b"r*" | b"r/" | b"r%" | b"r&" | b"r|" |
    b"r^" | b"+=" | b"-=" | b"*=" | b"/=" | b"%=" | b"&=" | b"|=" | b"^=" |
    b"=>" | b"@=" | b"->" | b"<-" | b"<=" | b">=" | b"&&" | b"--" |
    b"::" | b"||" | b"++"| b"?=" | b"===" | b"!==" | b"..." | b"r//" | b"r**" | b"r<<" | b"r>>" | b"//=" | b"**=" | b"<<=" |
    b">>=" | b"??" | b"|:"

    expression: {}


    operator:{
        assignment: {
            op:'=',
            type = "Binary",
            doc = "Assigns the value of the right operand to the left operand",
            precedence = 1,
            associativity = "Right to left",
            layout() -> {
                self::op
            }
        },
        equal_to: {
            op: "==",
            type = "Binary",
            doc = "Checks if the left operand is equal to the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        equal_to_location: {
            op: "===",
            type = "Binary",
            doc = "Checks if the location of the left operand is the same as the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        not_equal_to: {
            self: "!=",
            type = "Binary",
            doc = "Checks if the left operand is not equal to the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        greater_than: {
            op: ">",
            parent = super::expression,
            type = "Binary",
            doc = "Checks if the left operand is greater than the right operand",
            precedence = 3,
            associativity = "Left to right",
            layout() -> { self::op }

            assignment_layout -> { self::op super::expression }
        },
        less_than: {
            self: "<",
            rhs: super::expression,
            type = "Binary",
            doc = "Checks if the left operand is less than the right operand",
            precedence = 3,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        greater_than_or_equal_to: {
            self: ">=",
            type = "Binary",
            doc = "Checks if the left operand is greater than or equal to the right operand",
            precedence = 3,
            associativity = "Left to right",
        },
        less_than_or_equal_to: {
            self: "<=",
            type = "Binary",
            doc = "Checks if the left operand is less than or equal to the right operand",
            precedence = 3,
            associativity = "Left to right",
        },
        logical_and: {
            self: "&&",
            type = "Binary",
            doc = "Checks if both the left and right operands are true",
            precedence = 4,
            associativity = "Left to right",
        },
        logical_or: {
            self: "||",
            type = "Binary",
            doc = "Checks if either the left or right operand is true",
            precedence = 4,
            associativity = "Left to right",
        },
        logical_not: {
            self: "!",
            type = "Unary",
            doc = "Negates the value of the operand",
            precedence = 5,
            associativity = "Right to left",
        },
        bitwise_and: {
            self: "&",
            type = "Binary",
            doc = "Performs a bitwise AND operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_or: {
            self: "|",
            type = "Binary",
            doc = "Performs a bitwise OR operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_xor: {
            self: "^",
            type = "Binary",
            doc = "Performs a bitwise XOR operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_not: {
            self: "~",
            type = "Unary",
            doc = "Performs a bitwise NOT operation on the operand",
            precedence = 6,
            associativity = "Right to left",
        },
        shift_left: {
            self: "<<",
            type = "Binary",
            doc = "Shifts the bits of the left operand to the left by the number of bits specified by the right operand",
            precedence = 7,
            associativity = "Left to right",
        },
        shift_right: {
            self: ">>",
            type = "Binary",
            doc = "Shifts the bits of the left operand to the right by the number of bits specified by the right operand",
            precedence = 7,
            associativity = "Left to right",
        },
        add: {
            self: "+",
            type = "Binary",
            doc = "Adds the left and right operands",
            precedence = 8,
            associativity = "Left to right",
        },
        subtract: {
            self: "-",
            type = "Binary",
            doc = "Subtracts the right operand from the left operand",
            precedence = 8,
            associativity = "Left to right",
        },
        multiply: {
            self: "*",
            type = "Binary",
            doc = "Multiplies the left and right operands",
            precedence = 9,
            associativity = "Left to right",
        },
        divide: {
            self: "/",
            type = "Binary",
            doc = "Divides the left operand by the right operand",
            precedence = 9,
            associativity = "Left to right",
        },
        modulo: {
            self: "%",
            type = "Binary",
            doc = "Calculates the remainder of the left operand divided by the right operand",
            precedence = 9,
            associativity = "Left to right",
        },
        exponent: {
            self: "**",
            type = "Binary",
            doc = "Raises the left operand to the power of the right operand",
            precedence = 10,
            associativity = "Right to left",
        },
        increment: {
            self: "++",
            type = "Unary",
            doc = "Increments the value of the operand by 1",
            precedence = 11,
            associativity = "Right to left",
        },
        decrement: {
            self: "--",
            type = "Unary",
            doc = "Decrements the value of the operand by 1",
            precedence = 11,
            associativity = "Right to left",
        },







    }

        // TODO: name all of the

}

// TODO: Add this
#[derive(Debug, Clone)]
enum TokenType {
    String,
    Char,
    Numeric,
    Identifier,
    Delimiter,
    Operator,
    Comment,
    None,
}
// todo make ptr look up table for all match statements

// TODO: make a macro that converts the patten matching of rust to simd instructions
// so it looks like pattrn matching when using it in code, but its actually using simd instructions