
// todo make all non byte strings byte strings

// todo: formatter should be able to format macros, a macro can define what formatting to use
token_patterns! {

    delimiters: b'{' | b'}' | b'(' | b')' | b';' | b'!' | b'=' | b'|'|b':'|b','|b'<'|b'>' | b'?'|b'.',
    // two char delimeters

    newline: b'\n',

    other_whitespace: b'\t' | b'\x0C' | b'\r' | b' ',

    whitespace: other_whitespace!() | newline!(),
    // can use raw num bytes
    any: 0..=255,

    doc comment {
        single_line: {
            start:"//",
            end:"\n"

        },
        multi_line: {
            start:"/*",
            end:"*/"
        }
    },
    // todo: goto keyword

    scope : {
        start: '{',
        end: '}',
        separator: ';',
        // like a fn scope can contain return, break, continue, and other scopes
        can_contain(pattern:Pattern) -> {
            pattern
        }
    },

    struct array: {
        start: '[',
        end: ']',
        separator: ',',

        layout instantiation

    },// ident*:  means repeat

    tuple: {
        start: '(',
        end: ')',

        middle* : {
            separator: ',',
        }

        // makes it so a tuple will be parsed as a type
        type -> {
            start
        }

    },

    scope : {
        start: '{',
        end: '}',
        separator: ';',
        // like a fn scope can contain return, break, continue, and other scopes
        can_contain(pattern:Pattern) -> {
            pattern
        }
    }








    variable: {

        prefix: {
            mutable:  "mutable" | '~',
        },


        defined_as: ":",

        layout() -> {
            self::prefix super::identifier self::defined_as super::type
        }
    },



    function : {
        keyword: "fn",

        param : {
            start: '(',
            end: ')',
            suffix: {
                error: '?',
                layout() {// declares the order
                    error
                }
            }

            middle*: {
                separator:','

                layout() -> {
                    super::super::super:::variable self::separator*?  // optional end is *?
                }
            }


            layout() -> {
                self::start self::middle*? self::end self::suffix
            }
        },


        layout() -> {
            self::keyword self::param self::return error
        }

    },

    variable_definition : {
        // let ...
    }


    variable_type: {
        start: b":",
        end: b";",
        separator: b",",
    },

    method : {
        instance_call: b'.',
        static_call: b"::",
    },




    macro: {
        call: b'!',
    }




    fn_call_suffixes: macro_call!(),

    string_quotes: b'"',
    char_quotes: b'\'',

    quotes: string_quotes!() | char_quotes!(),

    backslash: b'\\',

    // raw | binary | unicode | formatted
    quote_prefixes: b'r' | b'b'| b'u'| b'f',
    // TODO: integrate this here ^
    prefixed_quotes: b"r\"" | b"b\""| b"u\""| b"f\"",

    // escape sequences
    // should we include regexp escape sequences in helix?
    // newline | carriage return | tab | null | hex | unicode | unicode extended | single quote
    escape_sequences: b"\\n" | b"\\r" | b"\\t" | b"\\0" | b"\\x" | b"\\u" | b"\\U" | b"\\'",


    two_len_ops: b"==" | b"!=" | b"<=" | b">=" | b"//" | b"**" |
    b"<<" | b">>" | b"r+" | b"r-"| b"r*" | b"r/" | b"r%" | b"r&" | b"r|" |
    b"r^" | b"+=" | b"-=" | b"*=" | b"/=" | b"%=" | b"&=" | b"|=" | b"^=" |
    b"=>" | b"@=" | b"->" | b"<-" | b"<=" | b">=" | b"&&" | b"--" |
    b"::" | b"||" | b"++" | b"__" | b"?=",



    three_len_ops: b"===" | b"!==" | b"..." | b"r//" | b"r**" | b"r<<" | b"r>>" | b"//=" | b"**=" | b"<<=" |
    b">>=" | b"??" | b"|:",

    // hex: numeric!() | b'a'..=b'f' | b'A'..=b'F',


    // method_call: b'.',
    // static_method_call: b"::",
    // method_error: b'?',


    // fn_definition_error_suffix: b'?',
    // fn_definition_suffixes: fn_definition_error_suffix!(),


    // fn_definition: b"fn",

    // // used for match statements
    // implies: b"=>",

    // fn_error: b'?',
    // // idk abt this copiolet gave this : fn_error_eq: b"?=",

    // fn_return: b"->",

    // fn_param_start: b'(',
    // fn_param_end: b')',

    // scope_start: b'{',
    // scope_end: b'}',

    // array_start: b'[',
    // array_end: b']',

    // tuple_start: b'(',
    // tuple_end: b')',

    // // make thing that does this

    // // numeric_prefix : {
    // //     // all of these patterns are in numeric prefix and also their own patterns that  can be used...
    // //     ordinal: b'o',
    // // }


    // // idk about big O
    // ordinal_numeric:b'o' ,

    // // little b is
    // binary_numeric: b'b',

    // // u is unicode. u4u32 would make it into the respective type from that char to the number
    // unicode_numeric: b'u',
    // numeric_hex: b'x' | b"0x",

    // big_endian: b'b',
    // little_endian: b'l',
    // native_endian: b'n',

    // numeric_endian_infixes: big_endian!() | little_endian!() | native_endian!(),
    // numeric_prefixes: ordinal!() |  binary_numeric!(),

    underscore: b'_',
    uppercase: b'A'..=b'Z',
    lowercase: b'a'..=b'z',
    numeric: b'0'..=b'9',

    alphanumeric: lowercase!() | uppercase!() | numeric!(),



    identifier: {
        prefix:{
            raw: b"r\"", // idk about this
        }
        first_char: lower_case!() | uppercase!() | underscore!(),
        rest: alphanumeric!() | underscore!(),

        layout() -> {
            first_char rest
        }
    },

    punctuation: b'!'..=b'/'|b':'..=b'@'|b'['..=b'`'|b'{'..=b'~',

    //TODO: make work -> operators: two_char_operators!() | three_char_operators!()

    operators:  b"==" | b"!=" | b"<=" | b">=" | b"//" | b"**" |
    b"<<" | b">>" | b"r+" | b"r-"| b"r*" | b"r/" | b"r%" | b"r&" | b"r|" |
    b"r^" | b"+=" | b"-=" | b"*=" | b"/=" | b"%=" | b"&=" | b"|=" | b"^=" |
    b"=>" | b"@=" | b"->" | b"<-" | b"<=" | b">=" | b"&&" | b"--" |
    b"::" | b"||" | b"++"| b"?=" | b"===" | b"!==" | b"..." | b"r//" | b"r**" | b"r<<" | b"r>>" | b"//=" | b"**=" | b"<<=" |
    b">>=" | b"??" | b"|:"

    expression: {}


    operator:{
        assignment: {
            op:'=',
            type = "Binary",
            doc = "Assigns the value of the right operand to the left operand",
            precedence = 1,
            associativity = "Right to left",
            layout() -> {
                self::op
            }
        },
        equal_to: {
            op: "==",
            type = "Binary",
            doc = "Checks if the left operand is equal to the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        equal_to_location: {
            op: "===",
            type = "Binary",
            doc = "Checks if the location of the left operand is the same as the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        not_equal_to: {
            self: "!=",
            type = "Binary",
            doc = "Checks if the left operand is not equal to the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        greater_than: {
            op: ">",
            parent = super::expression,
            type = "Binary",
            doc = "Checks if the left operand is greater than the right operand",
            precedence = 3,
            associativity = "Left to right",
            layout() -> { self::op }
            
            assignment_layout -> { self::op super::expression }
        },
        less_than: {
            self: "<",
            rhs: super::expression,
            type = "Binary",
            doc = "Checks if the left operand is less than the right operand",
            precedence = 3,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        greater_than_or_equal_to: {
            self: ">=",
            type = "Binary",
            doc = "Checks if the left operand is greater than or equal to the right operand",
            precedence = 3,
            associativity = "Left to right",
        },
        less_than_or_equal_to: {
            self: "<=",
            type = "Binary",
            doc = "Checks if the left operand is less than or equal to the right operand",
            precedence = 3,
            associativity = "Left to right",
        },
        logical_and: {
            self: "&&",
            type = "Binary",
            doc = "Checks if both the left and right operands are true",
            precedence = 4,
            associativity = "Left to right",
        },
        logical_or: {
            self: "||",
            type = "Binary",
            doc = "Checks if either the left or right operand is true",
            precedence = 4,
            associativity = "Left to right",
        },
        logical_not: {
            self: "!",
            type = "Unary",
            doc = "Negates the value of the operand",
            precedence = 5,
            associativity = "Right to left",
        },
        bitwise_and: {
            self: "&",
            type = "Binary",
            doc = "Performs a bitwise AND operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_or: {
            self: "|",
            type = "Binary",
            doc = "Performs a bitwise OR operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_xor: {
            self: "^",
            type = "Binary",
            doc = "Performs a bitwise XOR operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_not: {
            self: "~",
            type = "Unary",
            doc = "Performs a bitwise NOT operation on the operand",
            precedence = 6,
            associativity = "Right to left",
        },
        shift_left: {
            self: "<<",
            type = "Binary",
            doc = "Shifts the bits of the left operand to the left by the number of bits specified by the right operand",
            precedence = 7,
            associativity = "Left to right",
        },
        shift_right: {
            self: ">>",
            type = "Binary",
            doc = "Shifts the bits of the left operand to the right by the number of bits specified by the right operand",
            precedence = 7,
            associativity = "Left to right",
        },
        add: {
            self: "+",
            type = "Binary",
            doc = "Adds the left and right operands",
            precedence = 8,
            associativity = "Left to right",
        },
        subtract: {
            self: "-",
            type = "Binary",
            doc = "Subtracts the right operand from the left operand",
            precedence = 8,
            associativity = "Left to right",
        },
        multiply: {
            self: "*",
            type = "Binary",
            doc = "Multiplies the left and right operands",
            precedence = 9,
            associativity = "Left to right",
        },
        divide: {
            self: "/",
            type = "Binary",
            doc = "Divides the left operand by the right operand",
            precedence = 9,
            associativity = "Left to right",
        },
        modulo: {
            self: "%",
            type = "Binary",
            doc = "Calculates the remainder of the left operand divided by the right operand",
            precedence = 9,
            associativity = "Left to right",
        },
        exponent: {
            self: "**",
            type = "Binary",
            doc = "Raises the left operand to the power of the right operand",
            precedence = 10,
            associativity = "Right to left",
        },
        increment: {
            self: "++",
            type = "Unary",
            doc = "Increments the value of the operand by 1",
            precedence = 11,
            associativity = "Right to left",
        },
        decrement: {
            self: "--",
            type = "Unary",
            doc = "Decrements the value of the operand by 1",
            precedence = 11,
            associativity = "Right to left",
        },
        
        





    }

        // TODO: name all of the

}

// TODO: Add this
#[derive(Debug, Clone)]
enum TokenType {
    String,
    Char,
    Numeric,
    Identifier,
    Delimiter,
    Operator,
    Comment,
    None,
}
// todo make ptr look up table for all match statements

// TODO: make a macro that converts the patten matching of rust to simd instructions
// so it looks like pattrn matching when using it in code, but its actually using simd instructions
