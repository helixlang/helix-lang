interface Add<T> {
    fn +(other: T) -> T;
}

interface Sub<T> {
    fn -(other: T) -> T;
}

interface Mul<T> {
    fn *(other: T) -> T;
}

interface Div<T> {
    fn /(other: T) -> T;
}

interface Rem<T> {
    fn %(other: T) -> T;
}

interface Neg {
    fn -() -> Self;
}

interface Not {
    fn !() -> Self;
}

interface BitAnd<T> {
    fn &(other: T) -> T;
}

interface BitOr<T> {
    fn |(other: T) -> T;
}

interface BitXor<T> {
    fn ^(other: T) -> T;
}

interface Shl<T> {
    fn <<(other: T) -> T;
}

interface Shr<T> {
    fn >>(other: T) -> T;
}

interface Ops<T>::Add<T>+Sub<T>+Mul<T>+Div<T>+Rem<T>+Neg+Not+BitAnd<T>+BitOr<T>+BitXor<T>+Shl<T>+Shr<T> {
    fn +  (&self, other: Self)  -> Self { ... }
    fn -  (&self, other: Self)  -> Self { ... }
    fn *  (&self, other: Self)  -> Self { ... }
    fn /  (&self, other: Self)  -> Self { ... }
    fn %  (&self, other: Self)  -> Self { ... }
    fn |  (&self, other: Self)  -> Self { ... }
    fn &  (&self, other: Self)  -> Self { ... }
    fn ^  (&self, other: Self)  -> Self { ... }
    fn << (&self, other: Self)  -> Self { ... }
    fn >> (&self, other: Self)  -> Self { ... }
    fn !  (&self)               -> Self { ... }
    fn -  (&self)               -> Self { ... }
    fn ++ (&self)               -> Self { ... }
    fn -- (&self)               -> Self { ... }
    fn += (&self, other: Self)  -> Self { ... }
    fn -= (&self, other: Self)  -> Self { ... }
    fn *= (&self, other: Self)  -> Self { ... }
    fn /= (&self, other: Self)  -> Self { ... }
    fn %= (&self, other: Self)  -> Self { ... }
    fn |= (&self, other: Self)  -> Self { ... }
    fn &= (&self, other: Self)  -> Self { ... }
    fn ^= (&self, other: Self)  -> Self { ... }
    fn <<=(&self, other: Self)  -> Self { ... }
    fn >>=(&self, other: Self)  -> Self { ... }
}